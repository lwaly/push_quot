// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dataproxy.proto

#ifndef PROTOBUF_dataproxy_2eproto__INCLUDED
#define PROTOBUF_dataproxy_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace DataMem {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_dataproxy_2eproto();
void protobuf_AssignDesc_dataproxy_2eproto();
void protobuf_ShutdownFile_dataproxy_2eproto();

class MemOperate;
class MemOperate_RedisOperate;
class MemOperate_DbOperate;
class MemOperate_DbOperate_Condition;
class MemOperate_DbOperate_ConditionGroup;
class MemOperate_DbOperate_OrderBy;
class Record;
class Field;
class MemRsp;
class MemRsp_DataLocate;

enum MemOperate_RedisOperate_OPERATE_TYPE {
  MemOperate_RedisOperate_OPERATE_TYPE_T_READ = 1,
  MemOperate_RedisOperate_OPERATE_TYPE_T_WRITE = 2
};
bool MemOperate_RedisOperate_OPERATE_TYPE_IsValid(int value);
const MemOperate_RedisOperate_OPERATE_TYPE MemOperate_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_MIN = MemOperate_RedisOperate_OPERATE_TYPE_T_READ;
const MemOperate_RedisOperate_OPERATE_TYPE MemOperate_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_MAX = MemOperate_RedisOperate_OPERATE_TYPE_T_WRITE;
const int MemOperate_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_ARRAYSIZE = MemOperate_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* MemOperate_RedisOperate_OPERATE_TYPE_descriptor();
inline const ::std::string& MemOperate_RedisOperate_OPERATE_TYPE_Name(MemOperate_RedisOperate_OPERATE_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    MemOperate_RedisOperate_OPERATE_TYPE_descriptor(), value);
}
inline bool MemOperate_RedisOperate_OPERATE_TYPE_Parse(
    const ::std::string& name, MemOperate_RedisOperate_OPERATE_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MemOperate_RedisOperate_OPERATE_TYPE>(
    MemOperate_RedisOperate_OPERATE_TYPE_descriptor(), name, value);
}
enum MemOperate_DbOperate_Condition_E_RELATION {
  MemOperate_DbOperate_Condition_E_RELATION_EQ = 0,
  MemOperate_DbOperate_Condition_E_RELATION_NE = 1,
  MemOperate_DbOperate_Condition_E_RELATION_GT = 2,
  MemOperate_DbOperate_Condition_E_RELATION_LT = 3,
  MemOperate_DbOperate_Condition_E_RELATION_GE = 4,
  MemOperate_DbOperate_Condition_E_RELATION_LE = 5,
  MemOperate_DbOperate_Condition_E_RELATION_LIKE = 6,
  MemOperate_DbOperate_Condition_E_RELATION_IN = 7
};
bool MemOperate_DbOperate_Condition_E_RELATION_IsValid(int value);
const MemOperate_DbOperate_Condition_E_RELATION MemOperate_DbOperate_Condition_E_RELATION_E_RELATION_MIN = MemOperate_DbOperate_Condition_E_RELATION_EQ;
const MemOperate_DbOperate_Condition_E_RELATION MemOperate_DbOperate_Condition_E_RELATION_E_RELATION_MAX = MemOperate_DbOperate_Condition_E_RELATION_IN;
const int MemOperate_DbOperate_Condition_E_RELATION_E_RELATION_ARRAYSIZE = MemOperate_DbOperate_Condition_E_RELATION_E_RELATION_MAX + 1;

const ::google::protobuf::EnumDescriptor* MemOperate_DbOperate_Condition_E_RELATION_descriptor();
inline const ::std::string& MemOperate_DbOperate_Condition_E_RELATION_Name(MemOperate_DbOperate_Condition_E_RELATION value) {
  return ::google::protobuf::internal::NameOfEnum(
    MemOperate_DbOperate_Condition_E_RELATION_descriptor(), value);
}
inline bool MemOperate_DbOperate_Condition_E_RELATION_Parse(
    const ::std::string& name, MemOperate_DbOperate_Condition_E_RELATION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MemOperate_DbOperate_Condition_E_RELATION>(
    MemOperate_DbOperate_Condition_E_RELATION_descriptor(), name, value);
}
enum MemOperate_DbOperate_ConditionGroup_E_RELATION {
  MemOperate_DbOperate_ConditionGroup_E_RELATION_AND = 0,
  MemOperate_DbOperate_ConditionGroup_E_RELATION_OR = 1
};
bool MemOperate_DbOperate_ConditionGroup_E_RELATION_IsValid(int value);
const MemOperate_DbOperate_ConditionGroup_E_RELATION MemOperate_DbOperate_ConditionGroup_E_RELATION_E_RELATION_MIN = MemOperate_DbOperate_ConditionGroup_E_RELATION_AND;
const MemOperate_DbOperate_ConditionGroup_E_RELATION MemOperate_DbOperate_ConditionGroup_E_RELATION_E_RELATION_MAX = MemOperate_DbOperate_ConditionGroup_E_RELATION_OR;
const int MemOperate_DbOperate_ConditionGroup_E_RELATION_E_RELATION_ARRAYSIZE = MemOperate_DbOperate_ConditionGroup_E_RELATION_E_RELATION_MAX + 1;

const ::google::protobuf::EnumDescriptor* MemOperate_DbOperate_ConditionGroup_E_RELATION_descriptor();
inline const ::std::string& MemOperate_DbOperate_ConditionGroup_E_RELATION_Name(MemOperate_DbOperate_ConditionGroup_E_RELATION value) {
  return ::google::protobuf::internal::NameOfEnum(
    MemOperate_DbOperate_ConditionGroup_E_RELATION_descriptor(), value);
}
inline bool MemOperate_DbOperate_ConditionGroup_E_RELATION_Parse(
    const ::std::string& name, MemOperate_DbOperate_ConditionGroup_E_RELATION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MemOperate_DbOperate_ConditionGroup_E_RELATION>(
    MemOperate_DbOperate_ConditionGroup_E_RELATION_descriptor(), name, value);
}
enum MemOperate_DbOperate_OrderBy_E_RELATION {
  MemOperate_DbOperate_OrderBy_E_RELATION_ASC = 0,
  MemOperate_DbOperate_OrderBy_E_RELATION_DESC = 1
};
bool MemOperate_DbOperate_OrderBy_E_RELATION_IsValid(int value);
const MemOperate_DbOperate_OrderBy_E_RELATION MemOperate_DbOperate_OrderBy_E_RELATION_E_RELATION_MIN = MemOperate_DbOperate_OrderBy_E_RELATION_ASC;
const MemOperate_DbOperate_OrderBy_E_RELATION MemOperate_DbOperate_OrderBy_E_RELATION_E_RELATION_MAX = MemOperate_DbOperate_OrderBy_E_RELATION_DESC;
const int MemOperate_DbOperate_OrderBy_E_RELATION_E_RELATION_ARRAYSIZE = MemOperate_DbOperate_OrderBy_E_RELATION_E_RELATION_MAX + 1;

const ::google::protobuf::EnumDescriptor* MemOperate_DbOperate_OrderBy_E_RELATION_descriptor();
inline const ::std::string& MemOperate_DbOperate_OrderBy_E_RELATION_Name(MemOperate_DbOperate_OrderBy_E_RELATION value) {
  return ::google::protobuf::internal::NameOfEnum(
    MemOperate_DbOperate_OrderBy_E_RELATION_descriptor(), value);
}
inline bool MemOperate_DbOperate_OrderBy_E_RELATION_Parse(
    const ::std::string& name, MemOperate_DbOperate_OrderBy_E_RELATION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MemOperate_DbOperate_OrderBy_E_RELATION>(
    MemOperate_DbOperate_OrderBy_E_RELATION_descriptor(), name, value);
}
enum MemOperate_DbOperate_E_QUERY_TYPE {
  MemOperate_DbOperate_E_QUERY_TYPE_SELECT = 0,
  MemOperate_DbOperate_E_QUERY_TYPE_INSERT = 1,
  MemOperate_DbOperate_E_QUERY_TYPE_INSERT_IGNORE = 2,
  MemOperate_DbOperate_E_QUERY_TYPE_UPDATE = 3,
  MemOperate_DbOperate_E_QUERY_TYPE_REPLACE = 4,
  MemOperate_DbOperate_E_QUERY_TYPE_DELETE = 5
};
bool MemOperate_DbOperate_E_QUERY_TYPE_IsValid(int value);
const MemOperate_DbOperate_E_QUERY_TYPE MemOperate_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_MIN = MemOperate_DbOperate_E_QUERY_TYPE_SELECT;
const MemOperate_DbOperate_E_QUERY_TYPE MemOperate_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_MAX = MemOperate_DbOperate_E_QUERY_TYPE_DELETE;
const int MemOperate_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_ARRAYSIZE = MemOperate_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* MemOperate_DbOperate_E_QUERY_TYPE_descriptor();
inline const ::std::string& MemOperate_DbOperate_E_QUERY_TYPE_Name(MemOperate_DbOperate_E_QUERY_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    MemOperate_DbOperate_E_QUERY_TYPE_descriptor(), value);
}
inline bool MemOperate_DbOperate_E_QUERY_TYPE_Parse(
    const ::std::string& name, MemOperate_DbOperate_E_QUERY_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MemOperate_DbOperate_E_QUERY_TYPE>(
    MemOperate_DbOperate_E_QUERY_TYPE_descriptor(), name, value);
}
enum MemRsp_E_RESULT_FROM {
  MemRsp_E_RESULT_FROM_FROM_REDIS = 1,
  MemRsp_E_RESULT_FROM_FROM_DB = 2
};
bool MemRsp_E_RESULT_FROM_IsValid(int value);
const MemRsp_E_RESULT_FROM MemRsp_E_RESULT_FROM_E_RESULT_FROM_MIN = MemRsp_E_RESULT_FROM_FROM_REDIS;
const MemRsp_E_RESULT_FROM MemRsp_E_RESULT_FROM_E_RESULT_FROM_MAX = MemRsp_E_RESULT_FROM_FROM_DB;
const int MemRsp_E_RESULT_FROM_E_RESULT_FROM_ARRAYSIZE = MemRsp_E_RESULT_FROM_E_RESULT_FROM_MAX + 1;

const ::google::protobuf::EnumDescriptor* MemRsp_E_RESULT_FROM_descriptor();
inline const ::std::string& MemRsp_E_RESULT_FROM_Name(MemRsp_E_RESULT_FROM value) {
  return ::google::protobuf::internal::NameOfEnum(
    MemRsp_E_RESULT_FROM_descriptor(), value);
}
inline bool MemRsp_E_RESULT_FROM_Parse(
    const ::std::string& name, MemRsp_E_RESULT_FROM* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MemRsp_E_RESULT_FROM>(
    MemRsp_E_RESULT_FROM_descriptor(), name, value);
}
enum E_COL_TYPE {
  STRING = 0,
  INT = 1,
  BIGINT = 2,
  FLOAT = 3,
  DOUBLE = 4
};
bool E_COL_TYPE_IsValid(int value);
const E_COL_TYPE E_COL_TYPE_MIN = STRING;
const E_COL_TYPE E_COL_TYPE_MAX = DOUBLE;
const int E_COL_TYPE_ARRAYSIZE = E_COL_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* E_COL_TYPE_descriptor();
inline const ::std::string& E_COL_TYPE_Name(E_COL_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    E_COL_TYPE_descriptor(), value);
}
inline bool E_COL_TYPE_Parse(
    const ::std::string& name, E_COL_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<E_COL_TYPE>(
    E_COL_TYPE_descriptor(), name, value);
}
// ===================================================================

class MemOperate_RedisOperate : public ::google::protobuf::Message {
 public:
  MemOperate_RedisOperate();
  virtual ~MemOperate_RedisOperate();

  MemOperate_RedisOperate(const MemOperate_RedisOperate& from);

  inline MemOperate_RedisOperate& operator=(const MemOperate_RedisOperate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemOperate_RedisOperate& default_instance();

  void Swap(MemOperate_RedisOperate* other);

  // implements Message ----------------------------------------------

  MemOperate_RedisOperate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemOperate_RedisOperate& from);
  void MergeFrom(const MemOperate_RedisOperate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MemOperate_RedisOperate_OPERATE_TYPE OPERATE_TYPE;
  static const OPERATE_TYPE T_READ = MemOperate_RedisOperate_OPERATE_TYPE_T_READ;
  static const OPERATE_TYPE T_WRITE = MemOperate_RedisOperate_OPERATE_TYPE_T_WRITE;
  static inline bool OPERATE_TYPE_IsValid(int value) {
    return MemOperate_RedisOperate_OPERATE_TYPE_IsValid(value);
  }
  static const OPERATE_TYPE OPERATE_TYPE_MIN =
    MemOperate_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_MIN;
  static const OPERATE_TYPE OPERATE_TYPE_MAX =
    MemOperate_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_MAX;
  static const int OPERATE_TYPE_ARRAYSIZE =
    MemOperate_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OPERATE_TYPE_descriptor() {
    return MemOperate_RedisOperate_OPERATE_TYPE_descriptor();
  }
  static inline const ::std::string& OPERATE_TYPE_Name(OPERATE_TYPE value) {
    return MemOperate_RedisOperate_OPERATE_TYPE_Name(value);
  }
  static inline bool OPERATE_TYPE_Parse(const ::std::string& name,
      OPERATE_TYPE* value) {
    return MemOperate_RedisOperate_OPERATE_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required bytes key_name = 1;
  inline bool has_key_name() const;
  inline void clear_key_name();
  static const int kKeyNameFieldNumber = 1;
  inline const ::std::string& key_name() const;
  inline void set_key_name(const ::std::string& value);
  inline void set_key_name(const char* value);
  inline void set_key_name(const void* value, size_t size);
  inline ::std::string* mutable_key_name();
  inline ::std::string* release_key_name();
  inline void set_allocated_key_name(::std::string* key_name);

  // required string redis_cmd_read = 2;
  inline bool has_redis_cmd_read() const;
  inline void clear_redis_cmd_read();
  static const int kRedisCmdReadFieldNumber = 2;
  inline const ::std::string& redis_cmd_read() const;
  inline void set_redis_cmd_read(const ::std::string& value);
  inline void set_redis_cmd_read(const char* value);
  inline void set_redis_cmd_read(const char* value, size_t size);
  inline ::std::string* mutable_redis_cmd_read();
  inline ::std::string* release_redis_cmd_read();
  inline void set_allocated_redis_cmd_read(::std::string* redis_cmd_read);

  // required string redis_cmd_write = 3;
  inline bool has_redis_cmd_write() const;
  inline void clear_redis_cmd_write();
  static const int kRedisCmdWriteFieldNumber = 3;
  inline const ::std::string& redis_cmd_write() const;
  inline void set_redis_cmd_write(const ::std::string& value);
  inline void set_redis_cmd_write(const char* value);
  inline void set_redis_cmd_write(const char* value, size_t size);
  inline ::std::string* mutable_redis_cmd_write();
  inline ::std::string* release_redis_cmd_write();
  inline void set_allocated_redis_cmd_write(::std::string* redis_cmd_write);

  // required .DataMem.MemOperate.RedisOperate.OPERATE_TYPE op_type = 4;
  inline bool has_op_type() const;
  inline void clear_op_type();
  static const int kOpTypeFieldNumber = 4;
  inline ::DataMem::MemOperate_RedisOperate_OPERATE_TYPE op_type() const;
  inline void set_op_type(::DataMem::MemOperate_RedisOperate_OPERATE_TYPE value);

  // repeated .DataMem.Field fields = 5;
  inline int fields_size() const;
  inline void clear_fields();
  static const int kFieldsFieldNumber = 5;
  inline const ::DataMem::Field& fields(int index) const;
  inline ::DataMem::Field* mutable_fields(int index);
  inline ::DataMem::Field* add_fields();
  inline const ::google::protobuf::RepeatedPtrField< ::DataMem::Field >&
      fields() const;
  inline ::google::protobuf::RepeatedPtrField< ::DataMem::Field >*
      mutable_fields();

  // optional int32 key_ttl = 6;
  inline bool has_key_ttl() const;
  inline void clear_key_ttl();
  static const int kKeyTtlFieldNumber = 6;
  inline ::google::protobuf::int32 key_ttl() const;
  inline void set_key_ttl(::google::protobuf::int32 value);

  // optional int32 redis_structure = 7;
  inline bool has_redis_structure() const;
  inline void clear_redis_structure();
  static const int kRedisStructureFieldNumber = 7;
  inline ::google::protobuf::int32 redis_structure() const;
  inline void set_redis_structure(::google::protobuf::int32 value);

  // optional int32 data_purpose = 8;
  inline bool has_data_purpose() const;
  inline void clear_data_purpose();
  static const int kDataPurposeFieldNumber = 8;
  inline ::google::protobuf::int32 data_purpose() const;
  inline void set_data_purpose(::google::protobuf::int32 value);

  // optional bytes hash_key = 9;
  inline bool has_hash_key() const;
  inline void clear_hash_key();
  static const int kHashKeyFieldNumber = 9;
  inline const ::std::string& hash_key() const;
  inline void set_hash_key(const ::std::string& value);
  inline void set_hash_key(const char* value);
  inline void set_hash_key(const void* value, size_t size);
  inline ::std::string* mutable_hash_key();
  inline ::std::string* release_hash_key();
  inline void set_allocated_hash_key(::std::string* hash_key);

  // @@protoc_insertion_point(class_scope:DataMem.MemOperate.RedisOperate)
 private:
  inline void set_has_key_name();
  inline void clear_has_key_name();
  inline void set_has_redis_cmd_read();
  inline void clear_has_redis_cmd_read();
  inline void set_has_redis_cmd_write();
  inline void clear_has_redis_cmd_write();
  inline void set_has_op_type();
  inline void clear_has_op_type();
  inline void set_has_key_ttl();
  inline void clear_has_key_ttl();
  inline void set_has_redis_structure();
  inline void clear_has_redis_structure();
  inline void set_has_data_purpose();
  inline void clear_has_data_purpose();
  inline void set_has_hash_key();
  inline void clear_has_hash_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_name_;
  ::std::string* redis_cmd_read_;
  ::std::string* redis_cmd_write_;
  ::google::protobuf::RepeatedPtrField< ::DataMem::Field > fields_;
  int op_type_;
  ::google::protobuf::int32 key_ttl_;
  ::google::protobuf::int32 redis_structure_;
  ::google::protobuf::int32 data_purpose_;
  ::std::string* hash_key_;
  friend void  protobuf_AddDesc_dataproxy_2eproto();
  friend void protobuf_AssignDesc_dataproxy_2eproto();
  friend void protobuf_ShutdownFile_dataproxy_2eproto();

  void InitAsDefaultInstance();
  static MemOperate_RedisOperate* default_instance_;
};
// -------------------------------------------------------------------

class MemOperate_DbOperate_Condition : public ::google::protobuf::Message {
 public:
  MemOperate_DbOperate_Condition();
  virtual ~MemOperate_DbOperate_Condition();

  MemOperate_DbOperate_Condition(const MemOperate_DbOperate_Condition& from);

  inline MemOperate_DbOperate_Condition& operator=(const MemOperate_DbOperate_Condition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemOperate_DbOperate_Condition& default_instance();

  void Swap(MemOperate_DbOperate_Condition* other);

  // implements Message ----------------------------------------------

  MemOperate_DbOperate_Condition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemOperate_DbOperate_Condition& from);
  void MergeFrom(const MemOperate_DbOperate_Condition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MemOperate_DbOperate_Condition_E_RELATION E_RELATION;
  static const E_RELATION EQ = MemOperate_DbOperate_Condition_E_RELATION_EQ;
  static const E_RELATION NE = MemOperate_DbOperate_Condition_E_RELATION_NE;
  static const E_RELATION GT = MemOperate_DbOperate_Condition_E_RELATION_GT;
  static const E_RELATION LT = MemOperate_DbOperate_Condition_E_RELATION_LT;
  static const E_RELATION GE = MemOperate_DbOperate_Condition_E_RELATION_GE;
  static const E_RELATION LE = MemOperate_DbOperate_Condition_E_RELATION_LE;
  static const E_RELATION LIKE = MemOperate_DbOperate_Condition_E_RELATION_LIKE;
  static const E_RELATION IN = MemOperate_DbOperate_Condition_E_RELATION_IN;
  static inline bool E_RELATION_IsValid(int value) {
    return MemOperate_DbOperate_Condition_E_RELATION_IsValid(value);
  }
  static const E_RELATION E_RELATION_MIN =
    MemOperate_DbOperate_Condition_E_RELATION_E_RELATION_MIN;
  static const E_RELATION E_RELATION_MAX =
    MemOperate_DbOperate_Condition_E_RELATION_E_RELATION_MAX;
  static const int E_RELATION_ARRAYSIZE =
    MemOperate_DbOperate_Condition_E_RELATION_E_RELATION_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  E_RELATION_descriptor() {
    return MemOperate_DbOperate_Condition_E_RELATION_descriptor();
  }
  static inline const ::std::string& E_RELATION_Name(E_RELATION value) {
    return MemOperate_DbOperate_Condition_E_RELATION_Name(value);
  }
  static inline bool E_RELATION_Parse(const ::std::string& name,
      E_RELATION* value) {
    return MemOperate_DbOperate_Condition_E_RELATION_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .DataMem.MemOperate.DbOperate.Condition.E_RELATION relation = 1;
  inline bool has_relation() const;
  inline void clear_relation();
  static const int kRelationFieldNumber = 1;
  inline ::DataMem::MemOperate_DbOperate_Condition_E_RELATION relation() const;
  inline void set_relation(::DataMem::MemOperate_DbOperate_Condition_E_RELATION value);

  // required .DataMem.E_COL_TYPE col_type = 2;
  inline bool has_col_type() const;
  inline void clear_col_type();
  static const int kColTypeFieldNumber = 2;
  inline ::DataMem::E_COL_TYPE col_type() const;
  inline void set_col_type(::DataMem::E_COL_TYPE value);

  // required string col_name = 3;
  inline bool has_col_name() const;
  inline void clear_col_name();
  static const int kColNameFieldNumber = 3;
  inline const ::std::string& col_name() const;
  inline void set_col_name(const ::std::string& value);
  inline void set_col_name(const char* value);
  inline void set_col_name(const char* value, size_t size);
  inline ::std::string* mutable_col_name();
  inline ::std::string* release_col_name();
  inline void set_allocated_col_name(::std::string* col_name);

  // repeated bytes col_values = 4;
  inline int col_values_size() const;
  inline void clear_col_values();
  static const int kColValuesFieldNumber = 4;
  inline const ::std::string& col_values(int index) const;
  inline ::std::string* mutable_col_values(int index);
  inline void set_col_values(int index, const ::std::string& value);
  inline void set_col_values(int index, const char* value);
  inline void set_col_values(int index, const void* value, size_t size);
  inline ::std::string* add_col_values();
  inline void add_col_values(const ::std::string& value);
  inline void add_col_values(const char* value);
  inline void add_col_values(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& col_values() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_col_values();

  // optional string col_name_right = 5;
  inline bool has_col_name_right() const;
  inline void clear_col_name_right();
  static const int kColNameRightFieldNumber = 5;
  inline const ::std::string& col_name_right() const;
  inline void set_col_name_right(const ::std::string& value);
  inline void set_col_name_right(const char* value);
  inline void set_col_name_right(const char* value, size_t size);
  inline ::std::string* mutable_col_name_right();
  inline ::std::string* release_col_name_right();
  inline void set_allocated_col_name_right(::std::string* col_name_right);

  // @@protoc_insertion_point(class_scope:DataMem.MemOperate.DbOperate.Condition)
 private:
  inline void set_has_relation();
  inline void clear_has_relation();
  inline void set_has_col_type();
  inline void clear_has_col_type();
  inline void set_has_col_name();
  inline void clear_has_col_name();
  inline void set_has_col_name_right();
  inline void clear_has_col_name_right();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int relation_;
  int col_type_;
  ::std::string* col_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> col_values_;
  ::std::string* col_name_right_;
  friend void  protobuf_AddDesc_dataproxy_2eproto();
  friend void protobuf_AssignDesc_dataproxy_2eproto();
  friend void protobuf_ShutdownFile_dataproxy_2eproto();

  void InitAsDefaultInstance();
  static MemOperate_DbOperate_Condition* default_instance_;
};
// -------------------------------------------------------------------

class MemOperate_DbOperate_ConditionGroup : public ::google::protobuf::Message {
 public:
  MemOperate_DbOperate_ConditionGroup();
  virtual ~MemOperate_DbOperate_ConditionGroup();

  MemOperate_DbOperate_ConditionGroup(const MemOperate_DbOperate_ConditionGroup& from);

  inline MemOperate_DbOperate_ConditionGroup& operator=(const MemOperate_DbOperate_ConditionGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemOperate_DbOperate_ConditionGroup& default_instance();

  void Swap(MemOperate_DbOperate_ConditionGroup* other);

  // implements Message ----------------------------------------------

  MemOperate_DbOperate_ConditionGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemOperate_DbOperate_ConditionGroup& from);
  void MergeFrom(const MemOperate_DbOperate_ConditionGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MemOperate_DbOperate_ConditionGroup_E_RELATION E_RELATION;
  static const E_RELATION AND = MemOperate_DbOperate_ConditionGroup_E_RELATION_AND;
  static const E_RELATION OR = MemOperate_DbOperate_ConditionGroup_E_RELATION_OR;
  static inline bool E_RELATION_IsValid(int value) {
    return MemOperate_DbOperate_ConditionGroup_E_RELATION_IsValid(value);
  }
  static const E_RELATION E_RELATION_MIN =
    MemOperate_DbOperate_ConditionGroup_E_RELATION_E_RELATION_MIN;
  static const E_RELATION E_RELATION_MAX =
    MemOperate_DbOperate_ConditionGroup_E_RELATION_E_RELATION_MAX;
  static const int E_RELATION_ARRAYSIZE =
    MemOperate_DbOperate_ConditionGroup_E_RELATION_E_RELATION_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  E_RELATION_descriptor() {
    return MemOperate_DbOperate_ConditionGroup_E_RELATION_descriptor();
  }
  static inline const ::std::string& E_RELATION_Name(E_RELATION value) {
    return MemOperate_DbOperate_ConditionGroup_E_RELATION_Name(value);
  }
  static inline bool E_RELATION_Parse(const ::std::string& name,
      E_RELATION* value) {
    return MemOperate_DbOperate_ConditionGroup_E_RELATION_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .DataMem.MemOperate.DbOperate.ConditionGroup.E_RELATION relation = 1;
  inline bool has_relation() const;
  inline void clear_relation();
  static const int kRelationFieldNumber = 1;
  inline ::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION relation() const;
  inline void set_relation(::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION value);

  // repeated .DataMem.MemOperate.DbOperate.Condition condition = 2;
  inline int condition_size() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 2;
  inline const ::DataMem::MemOperate_DbOperate_Condition& condition(int index) const;
  inline ::DataMem::MemOperate_DbOperate_Condition* mutable_condition(int index);
  inline ::DataMem::MemOperate_DbOperate_Condition* add_condition();
  inline const ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_Condition >&
      condition() const;
  inline ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_Condition >*
      mutable_condition();

  // @@protoc_insertion_point(class_scope:DataMem.MemOperate.DbOperate.ConditionGroup)
 private:
  inline void set_has_relation();
  inline void clear_has_relation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_Condition > condition_;
  int relation_;
  friend void  protobuf_AddDesc_dataproxy_2eproto();
  friend void protobuf_AssignDesc_dataproxy_2eproto();
  friend void protobuf_ShutdownFile_dataproxy_2eproto();

  void InitAsDefaultInstance();
  static MemOperate_DbOperate_ConditionGroup* default_instance_;
};
// -------------------------------------------------------------------

class MemOperate_DbOperate_OrderBy : public ::google::protobuf::Message {
 public:
  MemOperate_DbOperate_OrderBy();
  virtual ~MemOperate_DbOperate_OrderBy();

  MemOperate_DbOperate_OrderBy(const MemOperate_DbOperate_OrderBy& from);

  inline MemOperate_DbOperate_OrderBy& operator=(const MemOperate_DbOperate_OrderBy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemOperate_DbOperate_OrderBy& default_instance();

  void Swap(MemOperate_DbOperate_OrderBy* other);

  // implements Message ----------------------------------------------

  MemOperate_DbOperate_OrderBy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemOperate_DbOperate_OrderBy& from);
  void MergeFrom(const MemOperate_DbOperate_OrderBy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MemOperate_DbOperate_OrderBy_E_RELATION E_RELATION;
  static const E_RELATION ASC = MemOperate_DbOperate_OrderBy_E_RELATION_ASC;
  static const E_RELATION DESC = MemOperate_DbOperate_OrderBy_E_RELATION_DESC;
  static inline bool E_RELATION_IsValid(int value) {
    return MemOperate_DbOperate_OrderBy_E_RELATION_IsValid(value);
  }
  static const E_RELATION E_RELATION_MIN =
    MemOperate_DbOperate_OrderBy_E_RELATION_E_RELATION_MIN;
  static const E_RELATION E_RELATION_MAX =
    MemOperate_DbOperate_OrderBy_E_RELATION_E_RELATION_MAX;
  static const int E_RELATION_ARRAYSIZE =
    MemOperate_DbOperate_OrderBy_E_RELATION_E_RELATION_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  E_RELATION_descriptor() {
    return MemOperate_DbOperate_OrderBy_E_RELATION_descriptor();
  }
  static inline const ::std::string& E_RELATION_Name(E_RELATION value) {
    return MemOperate_DbOperate_OrderBy_E_RELATION_Name(value);
  }
  static inline bool E_RELATION_Parse(const ::std::string& name,
      E_RELATION* value) {
    return MemOperate_DbOperate_OrderBy_E_RELATION_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .DataMem.MemOperate.DbOperate.OrderBy.E_RELATION relation = 1;
  inline bool has_relation() const;
  inline void clear_relation();
  static const int kRelationFieldNumber = 1;
  inline ::DataMem::MemOperate_DbOperate_OrderBy_E_RELATION relation() const;
  inline void set_relation(::DataMem::MemOperate_DbOperate_OrderBy_E_RELATION value);

  // required string col_name = 2;
  inline bool has_col_name() const;
  inline void clear_col_name();
  static const int kColNameFieldNumber = 2;
  inline const ::std::string& col_name() const;
  inline void set_col_name(const ::std::string& value);
  inline void set_col_name(const char* value);
  inline void set_col_name(const char* value, size_t size);
  inline ::std::string* mutable_col_name();
  inline ::std::string* release_col_name();
  inline void set_allocated_col_name(::std::string* col_name);

  // @@protoc_insertion_point(class_scope:DataMem.MemOperate.DbOperate.OrderBy)
 private:
  inline void set_has_relation();
  inline void clear_has_relation();
  inline void set_has_col_name();
  inline void clear_has_col_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* col_name_;
  int relation_;
  friend void  protobuf_AddDesc_dataproxy_2eproto();
  friend void protobuf_AssignDesc_dataproxy_2eproto();
  friend void protobuf_ShutdownFile_dataproxy_2eproto();

  void InitAsDefaultInstance();
  static MemOperate_DbOperate_OrderBy* default_instance_;
};
// -------------------------------------------------------------------

class MemOperate_DbOperate : public ::google::protobuf::Message {
 public:
  MemOperate_DbOperate();
  virtual ~MemOperate_DbOperate();

  MemOperate_DbOperate(const MemOperate_DbOperate& from);

  inline MemOperate_DbOperate& operator=(const MemOperate_DbOperate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemOperate_DbOperate& default_instance();

  void Swap(MemOperate_DbOperate* other);

  // implements Message ----------------------------------------------

  MemOperate_DbOperate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemOperate_DbOperate& from);
  void MergeFrom(const MemOperate_DbOperate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MemOperate_DbOperate_Condition Condition;
  typedef MemOperate_DbOperate_ConditionGroup ConditionGroup;
  typedef MemOperate_DbOperate_OrderBy OrderBy;

  typedef MemOperate_DbOperate_E_QUERY_TYPE E_QUERY_TYPE;
  static const E_QUERY_TYPE SELECT = MemOperate_DbOperate_E_QUERY_TYPE_SELECT;
  static const E_QUERY_TYPE INSERT = MemOperate_DbOperate_E_QUERY_TYPE_INSERT;
  static const E_QUERY_TYPE INSERT_IGNORE = MemOperate_DbOperate_E_QUERY_TYPE_INSERT_IGNORE;
  static const E_QUERY_TYPE UPDATE = MemOperate_DbOperate_E_QUERY_TYPE_UPDATE;
  static const E_QUERY_TYPE REPLACE = MemOperate_DbOperate_E_QUERY_TYPE_REPLACE;
  static const E_QUERY_TYPE DELETE = MemOperate_DbOperate_E_QUERY_TYPE_DELETE;
  static inline bool E_QUERY_TYPE_IsValid(int value) {
    return MemOperate_DbOperate_E_QUERY_TYPE_IsValid(value);
  }
  static const E_QUERY_TYPE E_QUERY_TYPE_MIN =
    MemOperate_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_MIN;
  static const E_QUERY_TYPE E_QUERY_TYPE_MAX =
    MemOperate_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_MAX;
  static const int E_QUERY_TYPE_ARRAYSIZE =
    MemOperate_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  E_QUERY_TYPE_descriptor() {
    return MemOperate_DbOperate_E_QUERY_TYPE_descriptor();
  }
  static inline const ::std::string& E_QUERY_TYPE_Name(E_QUERY_TYPE value) {
    return MemOperate_DbOperate_E_QUERY_TYPE_Name(value);
  }
  static inline bool E_QUERY_TYPE_Parse(const ::std::string& name,
      E_QUERY_TYPE* value) {
    return MemOperate_DbOperate_E_QUERY_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .DataMem.MemOperate.DbOperate.E_QUERY_TYPE query_type = 1;
  inline bool has_query_type() const;
  inline void clear_query_type();
  static const int kQueryTypeFieldNumber = 1;
  inline ::DataMem::MemOperate_DbOperate_E_QUERY_TYPE query_type() const;
  inline void set_query_type(::DataMem::MemOperate_DbOperate_E_QUERY_TYPE value);

  // required string table_name = 2;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 2;
  inline const ::std::string& table_name() const;
  inline void set_table_name(const ::std::string& value);
  inline void set_table_name(const char* value);
  inline void set_table_name(const char* value, size_t size);
  inline ::std::string* mutable_table_name();
  inline ::std::string* release_table_name();
  inline void set_allocated_table_name(::std::string* table_name);

  // repeated .DataMem.Field fields = 3;
  inline int fields_size() const;
  inline void clear_fields();
  static const int kFieldsFieldNumber = 3;
  inline const ::DataMem::Field& fields(int index) const;
  inline ::DataMem::Field* mutable_fields(int index);
  inline ::DataMem::Field* add_fields();
  inline const ::google::protobuf::RepeatedPtrField< ::DataMem::Field >&
      fields() const;
  inline ::google::protobuf::RepeatedPtrField< ::DataMem::Field >*
      mutable_fields();

  // repeated .DataMem.MemOperate.DbOperate.ConditionGroup conditions = 4;
  inline int conditions_size() const;
  inline void clear_conditions();
  static const int kConditionsFieldNumber = 4;
  inline const ::DataMem::MemOperate_DbOperate_ConditionGroup& conditions(int index) const;
  inline ::DataMem::MemOperate_DbOperate_ConditionGroup* mutable_conditions(int index);
  inline ::DataMem::MemOperate_DbOperate_ConditionGroup* add_conditions();
  inline const ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_ConditionGroup >&
      conditions() const;
  inline ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_ConditionGroup >*
      mutable_conditions();

  // repeated string groupby_col = 5;
  inline int groupby_col_size() const;
  inline void clear_groupby_col();
  static const int kGroupbyColFieldNumber = 5;
  inline const ::std::string& groupby_col(int index) const;
  inline ::std::string* mutable_groupby_col(int index);
  inline void set_groupby_col(int index, const ::std::string& value);
  inline void set_groupby_col(int index, const char* value);
  inline void set_groupby_col(int index, const char* value, size_t size);
  inline ::std::string* add_groupby_col();
  inline void add_groupby_col(const ::std::string& value);
  inline void add_groupby_col(const char* value);
  inline void add_groupby_col(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& groupby_col() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_groupby_col();

  // repeated .DataMem.MemOperate.DbOperate.OrderBy orderby_col = 6;
  inline int orderby_col_size() const;
  inline void clear_orderby_col();
  static const int kOrderbyColFieldNumber = 6;
  inline const ::DataMem::MemOperate_DbOperate_OrderBy& orderby_col(int index) const;
  inline ::DataMem::MemOperate_DbOperate_OrderBy* mutable_orderby_col(int index);
  inline ::DataMem::MemOperate_DbOperate_OrderBy* add_orderby_col();
  inline const ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_OrderBy >&
      orderby_col() const;
  inline ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_OrderBy >*
      mutable_orderby_col();

  // optional .DataMem.MemOperate.DbOperate.ConditionGroup.E_RELATION group_relation = 7;
  inline bool has_group_relation() const;
  inline void clear_group_relation();
  static const int kGroupRelationFieldNumber = 7;
  inline ::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION group_relation() const;
  inline void set_group_relation(::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION value);

  // optional uint32 limit = 8;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 8;
  inline ::google::protobuf::uint32 limit() const;
  inline void set_limit(::google::protobuf::uint32 value);

  // optional uint32 limit_from = 9;
  inline bool has_limit_from() const;
  inline void clear_limit_from();
  static const int kLimitFromFieldNumber = 9;
  inline ::google::protobuf::uint32 limit_from() const;
  inline void set_limit_from(::google::protobuf::uint32 value);

  // optional uint32 mod_factor = 10;
  inline bool has_mod_factor() const;
  inline void clear_mod_factor();
  static const int kModFactorFieldNumber = 10;
  inline ::google::protobuf::uint32 mod_factor() const;
  inline void set_mod_factor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DataMem.MemOperate.DbOperate)
 private:
  inline void set_has_query_type();
  inline void clear_has_query_type();
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_group_relation();
  inline void clear_has_group_relation();
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_limit_from();
  inline void clear_has_limit_from();
  inline void set_has_mod_factor();
  inline void clear_has_mod_factor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* table_name_;
  ::google::protobuf::RepeatedPtrField< ::DataMem::Field > fields_;
  ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_ConditionGroup > conditions_;
  int query_type_;
  int group_relation_;
  ::google::protobuf::RepeatedPtrField< ::std::string> groupby_col_;
  ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_OrderBy > orderby_col_;
  ::google::protobuf::uint32 limit_;
  ::google::protobuf::uint32 limit_from_;
  ::google::protobuf::uint32 mod_factor_;
  friend void  protobuf_AddDesc_dataproxy_2eproto();
  friend void protobuf_AssignDesc_dataproxy_2eproto();
  friend void protobuf_ShutdownFile_dataproxy_2eproto();

  void InitAsDefaultInstance();
  static MemOperate_DbOperate* default_instance_;
};
// -------------------------------------------------------------------

class MemOperate : public ::google::protobuf::Message {
 public:
  MemOperate();
  virtual ~MemOperate();

  MemOperate(const MemOperate& from);

  inline MemOperate& operator=(const MemOperate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemOperate& default_instance();

  void Swap(MemOperate* other);

  // implements Message ----------------------------------------------

  MemOperate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemOperate& from);
  void MergeFrom(const MemOperate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MemOperate_RedisOperate RedisOperate;
  typedef MemOperate_DbOperate DbOperate;

  // accessors -------------------------------------------------------

  // required uint32 section_factor = 1;
  inline bool has_section_factor() const;
  inline void clear_section_factor();
  static const int kSectionFactorFieldNumber = 1;
  inline ::google::protobuf::uint32 section_factor() const;
  inline void set_section_factor(::google::protobuf::uint32 value);

  // optional .DataMem.MemOperate.RedisOperate redis_operate = 2;
  inline bool has_redis_operate() const;
  inline void clear_redis_operate();
  static const int kRedisOperateFieldNumber = 2;
  inline const ::DataMem::MemOperate_RedisOperate& redis_operate() const;
  inline ::DataMem::MemOperate_RedisOperate* mutable_redis_operate();
  inline ::DataMem::MemOperate_RedisOperate* release_redis_operate();
  inline void set_allocated_redis_operate(::DataMem::MemOperate_RedisOperate* redis_operate);

  // optional .DataMem.MemOperate.DbOperate db_operate = 3;
  inline bool has_db_operate() const;
  inline void clear_db_operate();
  static const int kDbOperateFieldNumber = 3;
  inline const ::DataMem::MemOperate_DbOperate& db_operate() const;
  inline ::DataMem::MemOperate_DbOperate* mutable_db_operate();
  inline ::DataMem::MemOperate_DbOperate* release_db_operate();
  inline void set_allocated_db_operate(::DataMem::MemOperate_DbOperate* db_operate);

  // @@protoc_insertion_point(class_scope:DataMem.MemOperate)
 private:
  inline void set_has_section_factor();
  inline void clear_has_section_factor();
  inline void set_has_redis_operate();
  inline void clear_has_redis_operate();
  inline void set_has_db_operate();
  inline void clear_has_db_operate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DataMem::MemOperate_RedisOperate* redis_operate_;
  ::DataMem::MemOperate_DbOperate* db_operate_;
  ::google::protobuf::uint32 section_factor_;
  friend void  protobuf_AddDesc_dataproxy_2eproto();
  friend void protobuf_AssignDesc_dataproxy_2eproto();
  friend void protobuf_ShutdownFile_dataproxy_2eproto();

  void InitAsDefaultInstance();
  static MemOperate* default_instance_;
};
// -------------------------------------------------------------------

class Record : public ::google::protobuf::Message {
 public:
  Record();
  virtual ~Record();

  Record(const Record& from);

  inline Record& operator=(const Record& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Record& default_instance();

  void Swap(Record* other);

  // implements Message ----------------------------------------------

  Record* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Record& from);
  void MergeFrom(const Record& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DataMem.Field field_info = 1;
  inline int field_info_size() const;
  inline void clear_field_info();
  static const int kFieldInfoFieldNumber = 1;
  inline const ::DataMem::Field& field_info(int index) const;
  inline ::DataMem::Field* mutable_field_info(int index);
  inline ::DataMem::Field* add_field_info();
  inline const ::google::protobuf::RepeatedPtrField< ::DataMem::Field >&
      field_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::DataMem::Field >*
      mutable_field_info();

  // @@protoc_insertion_point(class_scope:DataMem.Record)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DataMem::Field > field_info_;
  friend void  protobuf_AddDesc_dataproxy_2eproto();
  friend void protobuf_AssignDesc_dataproxy_2eproto();
  friend void protobuf_ShutdownFile_dataproxy_2eproto();

  void InitAsDefaultInstance();
  static Record* default_instance_;
};
// -------------------------------------------------------------------

class Field : public ::google::protobuf::Message {
 public:
  Field();
  virtual ~Field();

  Field(const Field& from);

  inline Field& operator=(const Field& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Field& default_instance();

  void Swap(Field* other);

  // implements Message ----------------------------------------------

  Field* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Field& from);
  void MergeFrom(const Field& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string col_name = 1;
  inline bool has_col_name() const;
  inline void clear_col_name();
  static const int kColNameFieldNumber = 1;
  inline const ::std::string& col_name() const;
  inline void set_col_name(const ::std::string& value);
  inline void set_col_name(const char* value);
  inline void set_col_name(const char* value, size_t size);
  inline ::std::string* mutable_col_name();
  inline ::std::string* release_col_name();
  inline void set_allocated_col_name(::std::string* col_name);

  // optional .DataMem.E_COL_TYPE col_type = 2;
  inline bool has_col_type() const;
  inline void clear_col_type();
  static const int kColTypeFieldNumber = 2;
  inline ::DataMem::E_COL_TYPE col_type() const;
  inline void set_col_type(::DataMem::E_COL_TYPE value);

  // optional bytes col_value = 3;
  inline bool has_col_value() const;
  inline void clear_col_value();
  static const int kColValueFieldNumber = 3;
  inline const ::std::string& col_value() const;
  inline void set_col_value(const ::std::string& value);
  inline void set_col_value(const char* value);
  inline void set_col_value(const void* value, size_t size);
  inline ::std::string* mutable_col_value();
  inline ::std::string* release_col_value();
  inline void set_allocated_col_value(::std::string* col_value);

  // optional string col_as = 4;
  inline bool has_col_as() const;
  inline void clear_col_as();
  static const int kColAsFieldNumber = 4;
  inline const ::std::string& col_as() const;
  inline void set_col_as(const ::std::string& value);
  inline void set_col_as(const char* value);
  inline void set_col_as(const char* value, size_t size);
  inline ::std::string* mutable_col_as();
  inline ::std::string* release_col_as();
  inline void set_allocated_col_as(::std::string* col_as);

  // @@protoc_insertion_point(class_scope:DataMem.Field)
 private:
  inline void set_has_col_name();
  inline void clear_has_col_name();
  inline void set_has_col_type();
  inline void clear_has_col_type();
  inline void set_has_col_value();
  inline void clear_has_col_value();
  inline void set_has_col_as();
  inline void clear_has_col_as();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* col_name_;
  ::std::string* col_value_;
  ::std::string* col_as_;
  int col_type_;
  friend void  protobuf_AddDesc_dataproxy_2eproto();
  friend void protobuf_AssignDesc_dataproxy_2eproto();
  friend void protobuf_ShutdownFile_dataproxy_2eproto();

  void InitAsDefaultInstance();
  static Field* default_instance_;
};
// -------------------------------------------------------------------

class MemRsp_DataLocate : public ::google::protobuf::Message {
 public:
  MemRsp_DataLocate();
  virtual ~MemRsp_DataLocate();

  MemRsp_DataLocate(const MemRsp_DataLocate& from);

  inline MemRsp_DataLocate& operator=(const MemRsp_DataLocate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemRsp_DataLocate& default_instance();

  void Swap(MemRsp_DataLocate* other);

  // implements Message ----------------------------------------------

  MemRsp_DataLocate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemRsp_DataLocate& from);
  void MergeFrom(const MemRsp_DataLocate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 section_from = 1;
  inline bool has_section_from() const;
  inline void clear_section_from();
  static const int kSectionFromFieldNumber = 1;
  inline ::google::protobuf::uint32 section_from() const;
  inline void set_section_from(::google::protobuf::uint32 value);

  // required uint32 section_to = 2;
  inline bool has_section_to() const;
  inline void clear_section_to();
  static const int kSectionToFieldNumber = 2;
  inline ::google::protobuf::uint32 section_to() const;
  inline void set_section_to(::google::protobuf::uint32 value);

  // optional uint32 hash = 3;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 3;
  inline ::google::protobuf::uint32 hash() const;
  inline void set_hash(::google::protobuf::uint32 value);

  // optional uint32 divisor = 4;
  inline bool has_divisor() const;
  inline void clear_divisor();
  static const int kDivisorFieldNumber = 4;
  inline ::google::protobuf::uint32 divisor() const;
  inline void set_divisor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DataMem.MemRsp.DataLocate)
 private:
  inline void set_has_section_from();
  inline void clear_has_section_from();
  inline void set_has_section_to();
  inline void clear_has_section_to();
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_divisor();
  inline void clear_has_divisor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 section_from_;
  ::google::protobuf::uint32 section_to_;
  ::google::protobuf::uint32 hash_;
  ::google::protobuf::uint32 divisor_;
  friend void  protobuf_AddDesc_dataproxy_2eproto();
  friend void protobuf_AssignDesc_dataproxy_2eproto();
  friend void protobuf_ShutdownFile_dataproxy_2eproto();

  void InitAsDefaultInstance();
  static MemRsp_DataLocate* default_instance_;
};
// -------------------------------------------------------------------

class MemRsp : public ::google::protobuf::Message {
 public:
  MemRsp();
  virtual ~MemRsp();

  MemRsp(const MemRsp& from);

  inline MemRsp& operator=(const MemRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemRsp& default_instance();

  void Swap(MemRsp* other);

  // implements Message ----------------------------------------------

  MemRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemRsp& from);
  void MergeFrom(const MemRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MemRsp_DataLocate DataLocate;

  typedef MemRsp_E_RESULT_FROM E_RESULT_FROM;
  static const E_RESULT_FROM FROM_REDIS = MemRsp_E_RESULT_FROM_FROM_REDIS;
  static const E_RESULT_FROM FROM_DB = MemRsp_E_RESULT_FROM_FROM_DB;
  static inline bool E_RESULT_FROM_IsValid(int value) {
    return MemRsp_E_RESULT_FROM_IsValid(value);
  }
  static const E_RESULT_FROM E_RESULT_FROM_MIN =
    MemRsp_E_RESULT_FROM_E_RESULT_FROM_MIN;
  static const E_RESULT_FROM E_RESULT_FROM_MAX =
    MemRsp_E_RESULT_FROM_E_RESULT_FROM_MAX;
  static const int E_RESULT_FROM_ARRAYSIZE =
    MemRsp_E_RESULT_FROM_E_RESULT_FROM_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  E_RESULT_FROM_descriptor() {
    return MemRsp_E_RESULT_FROM_descriptor();
  }
  static inline const ::std::string& E_RESULT_FROM_Name(E_RESULT_FROM value) {
    return MemRsp_E_RESULT_FROM_Name(value);
  }
  static inline bool E_RESULT_FROM_Parse(const ::std::string& name,
      E_RESULT_FROM* value) {
    return MemRsp_E_RESULT_FROM_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 err_no = 1;
  inline bool has_err_no() const;
  inline void clear_err_no();
  static const int kErrNoFieldNumber = 1;
  inline ::google::protobuf::int32 err_no() const;
  inline void set_err_no(::google::protobuf::int32 value);

  // optional bytes err_msg = 2;
  inline bool has_err_msg() const;
  inline void clear_err_msg();
  static const int kErrMsgFieldNumber = 2;
  inline const ::std::string& err_msg() const;
  inline void set_err_msg(const ::std::string& value);
  inline void set_err_msg(const char* value);
  inline void set_err_msg(const void* value, size_t size);
  inline ::std::string* mutable_err_msg();
  inline ::std::string* release_err_msg();
  inline void set_allocated_err_msg(::std::string* err_msg);

  // optional int32 totalcount = 3;
  inline bool has_totalcount() const;
  inline void clear_totalcount();
  static const int kTotalcountFieldNumber = 3;
  inline ::google::protobuf::int32 totalcount() const;
  inline void set_totalcount(::google::protobuf::int32 value);

  // optional int32 curcount = 4;
  inline bool has_curcount() const;
  inline void clear_curcount();
  static const int kCurcountFieldNumber = 4;
  inline ::google::protobuf::int32 curcount() const;
  inline void set_curcount(::google::protobuf::int32 value);

  // repeated .DataMem.Record record_data = 5;
  inline int record_data_size() const;
  inline void clear_record_data();
  static const int kRecordDataFieldNumber = 5;
  inline const ::DataMem::Record& record_data(int index) const;
  inline ::DataMem::Record* mutable_record_data(int index);
  inline ::DataMem::Record* add_record_data();
  inline const ::google::protobuf::RepeatedPtrField< ::DataMem::Record >&
      record_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::DataMem::Record >*
      mutable_record_data();

  // optional int32 from = 6;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 6;
  inline ::google::protobuf::int32 from() const;
  inline void set_from(::google::protobuf::int32 value);

  // optional .DataMem.MemRsp.DataLocate locate = 7;
  inline bool has_locate() const;
  inline void clear_locate();
  static const int kLocateFieldNumber = 7;
  inline const ::DataMem::MemRsp_DataLocate& locate() const;
  inline ::DataMem::MemRsp_DataLocate* mutable_locate();
  inline ::DataMem::MemRsp_DataLocate* release_locate();
  inline void set_allocated_locate(::DataMem::MemRsp_DataLocate* locate);

  // @@protoc_insertion_point(class_scope:DataMem.MemRsp)
 private:
  inline void set_has_err_no();
  inline void clear_has_err_no();
  inline void set_has_err_msg();
  inline void clear_has_err_msg();
  inline void set_has_totalcount();
  inline void clear_has_totalcount();
  inline void set_has_curcount();
  inline void clear_has_curcount();
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_locate();
  inline void clear_has_locate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* err_msg_;
  ::google::protobuf::int32 err_no_;
  ::google::protobuf::int32 totalcount_;
  ::google::protobuf::RepeatedPtrField< ::DataMem::Record > record_data_;
  ::google::protobuf::int32 curcount_;
  ::google::protobuf::int32 from_;
  ::DataMem::MemRsp_DataLocate* locate_;
  friend void  protobuf_AddDesc_dataproxy_2eproto();
  friend void protobuf_AssignDesc_dataproxy_2eproto();
  friend void protobuf_ShutdownFile_dataproxy_2eproto();

  void InitAsDefaultInstance();
  static MemRsp* default_instance_;
};
// ===================================================================


// ===================================================================

// MemOperate_RedisOperate

// required bytes key_name = 1;
inline bool MemOperate_RedisOperate::has_key_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemOperate_RedisOperate::set_has_key_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemOperate_RedisOperate::clear_has_key_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemOperate_RedisOperate::clear_key_name() {
  if (key_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_name_->clear();
  }
  clear_has_key_name();
}
inline const ::std::string& MemOperate_RedisOperate::key_name() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.RedisOperate.key_name)
  return *key_name_;
}
inline void MemOperate_RedisOperate::set_key_name(const ::std::string& value) {
  set_has_key_name();
  if (key_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_name_ = new ::std::string;
  }
  key_name_->assign(value);
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.RedisOperate.key_name)
}
inline void MemOperate_RedisOperate::set_key_name(const char* value) {
  set_has_key_name();
  if (key_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_name_ = new ::std::string;
  }
  key_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:DataMem.MemOperate.RedisOperate.key_name)
}
inline void MemOperate_RedisOperate::set_key_name(const void* value, size_t size) {
  set_has_key_name();
  if (key_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_name_ = new ::std::string;
  }
  key_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DataMem.MemOperate.RedisOperate.key_name)
}
inline ::std::string* MemOperate_RedisOperate::mutable_key_name() {
  set_has_key_name();
  if (key_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.RedisOperate.key_name)
  return key_name_;
}
inline ::std::string* MemOperate_RedisOperate::release_key_name() {
  clear_has_key_name();
  if (key_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_name_;
    key_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MemOperate_RedisOperate::set_allocated_key_name(::std::string* key_name) {
  if (key_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_name_;
  }
  if (key_name) {
    set_has_key_name();
    key_name_ = key_name;
  } else {
    clear_has_key_name();
    key_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DataMem.MemOperate.RedisOperate.key_name)
}

// required string redis_cmd_read = 2;
inline bool MemOperate_RedisOperate::has_redis_cmd_read() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemOperate_RedisOperate::set_has_redis_cmd_read() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemOperate_RedisOperate::clear_has_redis_cmd_read() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemOperate_RedisOperate::clear_redis_cmd_read() {
  if (redis_cmd_read_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    redis_cmd_read_->clear();
  }
  clear_has_redis_cmd_read();
}
inline const ::std::string& MemOperate_RedisOperate::redis_cmd_read() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.RedisOperate.redis_cmd_read)
  return *redis_cmd_read_;
}
inline void MemOperate_RedisOperate::set_redis_cmd_read(const ::std::string& value) {
  set_has_redis_cmd_read();
  if (redis_cmd_read_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    redis_cmd_read_ = new ::std::string;
  }
  redis_cmd_read_->assign(value);
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.RedisOperate.redis_cmd_read)
}
inline void MemOperate_RedisOperate::set_redis_cmd_read(const char* value) {
  set_has_redis_cmd_read();
  if (redis_cmd_read_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    redis_cmd_read_ = new ::std::string;
  }
  redis_cmd_read_->assign(value);
  // @@protoc_insertion_point(field_set_char:DataMem.MemOperate.RedisOperate.redis_cmd_read)
}
inline void MemOperate_RedisOperate::set_redis_cmd_read(const char* value, size_t size) {
  set_has_redis_cmd_read();
  if (redis_cmd_read_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    redis_cmd_read_ = new ::std::string;
  }
  redis_cmd_read_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DataMem.MemOperate.RedisOperate.redis_cmd_read)
}
inline ::std::string* MemOperate_RedisOperate::mutable_redis_cmd_read() {
  set_has_redis_cmd_read();
  if (redis_cmd_read_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    redis_cmd_read_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.RedisOperate.redis_cmd_read)
  return redis_cmd_read_;
}
inline ::std::string* MemOperate_RedisOperate::release_redis_cmd_read() {
  clear_has_redis_cmd_read();
  if (redis_cmd_read_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = redis_cmd_read_;
    redis_cmd_read_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MemOperate_RedisOperate::set_allocated_redis_cmd_read(::std::string* redis_cmd_read) {
  if (redis_cmd_read_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete redis_cmd_read_;
  }
  if (redis_cmd_read) {
    set_has_redis_cmd_read();
    redis_cmd_read_ = redis_cmd_read;
  } else {
    clear_has_redis_cmd_read();
    redis_cmd_read_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DataMem.MemOperate.RedisOperate.redis_cmd_read)
}

// required string redis_cmd_write = 3;
inline bool MemOperate_RedisOperate::has_redis_cmd_write() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemOperate_RedisOperate::set_has_redis_cmd_write() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemOperate_RedisOperate::clear_has_redis_cmd_write() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemOperate_RedisOperate::clear_redis_cmd_write() {
  if (redis_cmd_write_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    redis_cmd_write_->clear();
  }
  clear_has_redis_cmd_write();
}
inline const ::std::string& MemOperate_RedisOperate::redis_cmd_write() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.RedisOperate.redis_cmd_write)
  return *redis_cmd_write_;
}
inline void MemOperate_RedisOperate::set_redis_cmd_write(const ::std::string& value) {
  set_has_redis_cmd_write();
  if (redis_cmd_write_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    redis_cmd_write_ = new ::std::string;
  }
  redis_cmd_write_->assign(value);
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.RedisOperate.redis_cmd_write)
}
inline void MemOperate_RedisOperate::set_redis_cmd_write(const char* value) {
  set_has_redis_cmd_write();
  if (redis_cmd_write_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    redis_cmd_write_ = new ::std::string;
  }
  redis_cmd_write_->assign(value);
  // @@protoc_insertion_point(field_set_char:DataMem.MemOperate.RedisOperate.redis_cmd_write)
}
inline void MemOperate_RedisOperate::set_redis_cmd_write(const char* value, size_t size) {
  set_has_redis_cmd_write();
  if (redis_cmd_write_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    redis_cmd_write_ = new ::std::string;
  }
  redis_cmd_write_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DataMem.MemOperate.RedisOperate.redis_cmd_write)
}
inline ::std::string* MemOperate_RedisOperate::mutable_redis_cmd_write() {
  set_has_redis_cmd_write();
  if (redis_cmd_write_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    redis_cmd_write_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.RedisOperate.redis_cmd_write)
  return redis_cmd_write_;
}
inline ::std::string* MemOperate_RedisOperate::release_redis_cmd_write() {
  clear_has_redis_cmd_write();
  if (redis_cmd_write_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = redis_cmd_write_;
    redis_cmd_write_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MemOperate_RedisOperate::set_allocated_redis_cmd_write(::std::string* redis_cmd_write) {
  if (redis_cmd_write_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete redis_cmd_write_;
  }
  if (redis_cmd_write) {
    set_has_redis_cmd_write();
    redis_cmd_write_ = redis_cmd_write;
  } else {
    clear_has_redis_cmd_write();
    redis_cmd_write_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DataMem.MemOperate.RedisOperate.redis_cmd_write)
}

// required .DataMem.MemOperate.RedisOperate.OPERATE_TYPE op_type = 4;
inline bool MemOperate_RedisOperate::has_op_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MemOperate_RedisOperate::set_has_op_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MemOperate_RedisOperate::clear_has_op_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MemOperate_RedisOperate::clear_op_type() {
  op_type_ = 1;
  clear_has_op_type();
}
inline ::DataMem::MemOperate_RedisOperate_OPERATE_TYPE MemOperate_RedisOperate::op_type() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.RedisOperate.op_type)
  return static_cast< ::DataMem::MemOperate_RedisOperate_OPERATE_TYPE >(op_type_);
}
inline void MemOperate_RedisOperate::set_op_type(::DataMem::MemOperate_RedisOperate_OPERATE_TYPE value) {
  assert(::DataMem::MemOperate_RedisOperate_OPERATE_TYPE_IsValid(value));
  set_has_op_type();
  op_type_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.RedisOperate.op_type)
}

// repeated .DataMem.Field fields = 5;
inline int MemOperate_RedisOperate::fields_size() const {
  return fields_.size();
}
inline void MemOperate_RedisOperate::clear_fields() {
  fields_.Clear();
}
inline const ::DataMem::Field& MemOperate_RedisOperate::fields(int index) const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.RedisOperate.fields)
  return fields_.Get(index);
}
inline ::DataMem::Field* MemOperate_RedisOperate::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.RedisOperate.fields)
  return fields_.Mutable(index);
}
inline ::DataMem::Field* MemOperate_RedisOperate::add_fields() {
  // @@protoc_insertion_point(field_add:DataMem.MemOperate.RedisOperate.fields)
  return fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DataMem::Field >&
MemOperate_RedisOperate::fields() const {
  // @@protoc_insertion_point(field_list:DataMem.MemOperate.RedisOperate.fields)
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::DataMem::Field >*
MemOperate_RedisOperate::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:DataMem.MemOperate.RedisOperate.fields)
  return &fields_;
}

// optional int32 key_ttl = 6;
inline bool MemOperate_RedisOperate::has_key_ttl() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MemOperate_RedisOperate::set_has_key_ttl() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MemOperate_RedisOperate::clear_has_key_ttl() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MemOperate_RedisOperate::clear_key_ttl() {
  key_ttl_ = 0;
  clear_has_key_ttl();
}
inline ::google::protobuf::int32 MemOperate_RedisOperate::key_ttl() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.RedisOperate.key_ttl)
  return key_ttl_;
}
inline void MemOperate_RedisOperate::set_key_ttl(::google::protobuf::int32 value) {
  set_has_key_ttl();
  key_ttl_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.RedisOperate.key_ttl)
}

// optional int32 redis_structure = 7;
inline bool MemOperate_RedisOperate::has_redis_structure() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MemOperate_RedisOperate::set_has_redis_structure() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MemOperate_RedisOperate::clear_has_redis_structure() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MemOperate_RedisOperate::clear_redis_structure() {
  redis_structure_ = 0;
  clear_has_redis_structure();
}
inline ::google::protobuf::int32 MemOperate_RedisOperate::redis_structure() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.RedisOperate.redis_structure)
  return redis_structure_;
}
inline void MemOperate_RedisOperate::set_redis_structure(::google::protobuf::int32 value) {
  set_has_redis_structure();
  redis_structure_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.RedisOperate.redis_structure)
}

// optional int32 data_purpose = 8;
inline bool MemOperate_RedisOperate::has_data_purpose() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MemOperate_RedisOperate::set_has_data_purpose() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MemOperate_RedisOperate::clear_has_data_purpose() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MemOperate_RedisOperate::clear_data_purpose() {
  data_purpose_ = 0;
  clear_has_data_purpose();
}
inline ::google::protobuf::int32 MemOperate_RedisOperate::data_purpose() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.RedisOperate.data_purpose)
  return data_purpose_;
}
inline void MemOperate_RedisOperate::set_data_purpose(::google::protobuf::int32 value) {
  set_has_data_purpose();
  data_purpose_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.RedisOperate.data_purpose)
}

// optional bytes hash_key = 9;
inline bool MemOperate_RedisOperate::has_hash_key() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MemOperate_RedisOperate::set_has_hash_key() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MemOperate_RedisOperate::clear_has_hash_key() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MemOperate_RedisOperate::clear_hash_key() {
  if (hash_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_key_->clear();
  }
  clear_has_hash_key();
}
inline const ::std::string& MemOperate_RedisOperate::hash_key() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.RedisOperate.hash_key)
  return *hash_key_;
}
inline void MemOperate_RedisOperate::set_hash_key(const ::std::string& value) {
  set_has_hash_key();
  if (hash_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_key_ = new ::std::string;
  }
  hash_key_->assign(value);
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.RedisOperate.hash_key)
}
inline void MemOperate_RedisOperate::set_hash_key(const char* value) {
  set_has_hash_key();
  if (hash_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_key_ = new ::std::string;
  }
  hash_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:DataMem.MemOperate.RedisOperate.hash_key)
}
inline void MemOperate_RedisOperate::set_hash_key(const void* value, size_t size) {
  set_has_hash_key();
  if (hash_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_key_ = new ::std::string;
  }
  hash_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DataMem.MemOperate.RedisOperate.hash_key)
}
inline ::std::string* MemOperate_RedisOperate::mutable_hash_key() {
  set_has_hash_key();
  if (hash_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.RedisOperate.hash_key)
  return hash_key_;
}
inline ::std::string* MemOperate_RedisOperate::release_hash_key() {
  clear_has_hash_key();
  if (hash_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hash_key_;
    hash_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MemOperate_RedisOperate::set_allocated_hash_key(::std::string* hash_key) {
  if (hash_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hash_key_;
  }
  if (hash_key) {
    set_has_hash_key();
    hash_key_ = hash_key;
  } else {
    clear_has_hash_key();
    hash_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DataMem.MemOperate.RedisOperate.hash_key)
}

// -------------------------------------------------------------------

// MemOperate_DbOperate_Condition

// required .DataMem.MemOperate.DbOperate.Condition.E_RELATION relation = 1;
inline bool MemOperate_DbOperate_Condition::has_relation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemOperate_DbOperate_Condition::set_has_relation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemOperate_DbOperate_Condition::clear_has_relation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemOperate_DbOperate_Condition::clear_relation() {
  relation_ = 0;
  clear_has_relation();
}
inline ::DataMem::MemOperate_DbOperate_Condition_E_RELATION MemOperate_DbOperate_Condition::relation() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.Condition.relation)
  return static_cast< ::DataMem::MemOperate_DbOperate_Condition_E_RELATION >(relation_);
}
inline void MemOperate_DbOperate_Condition::set_relation(::DataMem::MemOperate_DbOperate_Condition_E_RELATION value) {
  assert(::DataMem::MemOperate_DbOperate_Condition_E_RELATION_IsValid(value));
  set_has_relation();
  relation_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.Condition.relation)
}

// required .DataMem.E_COL_TYPE col_type = 2;
inline bool MemOperate_DbOperate_Condition::has_col_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemOperate_DbOperate_Condition::set_has_col_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemOperate_DbOperate_Condition::clear_has_col_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemOperate_DbOperate_Condition::clear_col_type() {
  col_type_ = 0;
  clear_has_col_type();
}
inline ::DataMem::E_COL_TYPE MemOperate_DbOperate_Condition::col_type() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.Condition.col_type)
  return static_cast< ::DataMem::E_COL_TYPE >(col_type_);
}
inline void MemOperate_DbOperate_Condition::set_col_type(::DataMem::E_COL_TYPE value) {
  assert(::DataMem::E_COL_TYPE_IsValid(value));
  set_has_col_type();
  col_type_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.Condition.col_type)
}

// required string col_name = 3;
inline bool MemOperate_DbOperate_Condition::has_col_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemOperate_DbOperate_Condition::set_has_col_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemOperate_DbOperate_Condition::clear_has_col_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemOperate_DbOperate_Condition::clear_col_name() {
  if (col_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_name_->clear();
  }
  clear_has_col_name();
}
inline const ::std::string& MemOperate_DbOperate_Condition::col_name() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.Condition.col_name)
  return *col_name_;
}
inline void MemOperate_DbOperate_Condition::set_col_name(const ::std::string& value) {
  set_has_col_name();
  if (col_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_name_ = new ::std::string;
  }
  col_name_->assign(value);
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.Condition.col_name)
}
inline void MemOperate_DbOperate_Condition::set_col_name(const char* value) {
  set_has_col_name();
  if (col_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_name_ = new ::std::string;
  }
  col_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:DataMem.MemOperate.DbOperate.Condition.col_name)
}
inline void MemOperate_DbOperate_Condition::set_col_name(const char* value, size_t size) {
  set_has_col_name();
  if (col_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_name_ = new ::std::string;
  }
  col_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DataMem.MemOperate.DbOperate.Condition.col_name)
}
inline ::std::string* MemOperate_DbOperate_Condition::mutable_col_name() {
  set_has_col_name();
  if (col_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.DbOperate.Condition.col_name)
  return col_name_;
}
inline ::std::string* MemOperate_DbOperate_Condition::release_col_name() {
  clear_has_col_name();
  if (col_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = col_name_;
    col_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MemOperate_DbOperate_Condition::set_allocated_col_name(::std::string* col_name) {
  if (col_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete col_name_;
  }
  if (col_name) {
    set_has_col_name();
    col_name_ = col_name;
  } else {
    clear_has_col_name();
    col_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DataMem.MemOperate.DbOperate.Condition.col_name)
}

// repeated bytes col_values = 4;
inline int MemOperate_DbOperate_Condition::col_values_size() const {
  return col_values_.size();
}
inline void MemOperate_DbOperate_Condition::clear_col_values() {
  col_values_.Clear();
}
inline const ::std::string& MemOperate_DbOperate_Condition::col_values(int index) const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.Condition.col_values)
  return col_values_.Get(index);
}
inline ::std::string* MemOperate_DbOperate_Condition::mutable_col_values(int index) {
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.DbOperate.Condition.col_values)
  return col_values_.Mutable(index);
}
inline void MemOperate_DbOperate_Condition::set_col_values(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.Condition.col_values)
  col_values_.Mutable(index)->assign(value);
}
inline void MemOperate_DbOperate_Condition::set_col_values(int index, const char* value) {
  col_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DataMem.MemOperate.DbOperate.Condition.col_values)
}
inline void MemOperate_DbOperate_Condition::set_col_values(int index, const void* value, size_t size) {
  col_values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DataMem.MemOperate.DbOperate.Condition.col_values)
}
inline ::std::string* MemOperate_DbOperate_Condition::add_col_values() {
  return col_values_.Add();
}
inline void MemOperate_DbOperate_Condition::add_col_values(const ::std::string& value) {
  col_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DataMem.MemOperate.DbOperate.Condition.col_values)
}
inline void MemOperate_DbOperate_Condition::add_col_values(const char* value) {
  col_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DataMem.MemOperate.DbOperate.Condition.col_values)
}
inline void MemOperate_DbOperate_Condition::add_col_values(const void* value, size_t size) {
  col_values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DataMem.MemOperate.DbOperate.Condition.col_values)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MemOperate_DbOperate_Condition::col_values() const {
  // @@protoc_insertion_point(field_list:DataMem.MemOperate.DbOperate.Condition.col_values)
  return col_values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MemOperate_DbOperate_Condition::mutable_col_values() {
  // @@protoc_insertion_point(field_mutable_list:DataMem.MemOperate.DbOperate.Condition.col_values)
  return &col_values_;
}

// optional string col_name_right = 5;
inline bool MemOperate_DbOperate_Condition::has_col_name_right() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MemOperate_DbOperate_Condition::set_has_col_name_right() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MemOperate_DbOperate_Condition::clear_has_col_name_right() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MemOperate_DbOperate_Condition::clear_col_name_right() {
  if (col_name_right_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_name_right_->clear();
  }
  clear_has_col_name_right();
}
inline const ::std::string& MemOperate_DbOperate_Condition::col_name_right() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.Condition.col_name_right)
  return *col_name_right_;
}
inline void MemOperate_DbOperate_Condition::set_col_name_right(const ::std::string& value) {
  set_has_col_name_right();
  if (col_name_right_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_name_right_ = new ::std::string;
  }
  col_name_right_->assign(value);
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.Condition.col_name_right)
}
inline void MemOperate_DbOperate_Condition::set_col_name_right(const char* value) {
  set_has_col_name_right();
  if (col_name_right_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_name_right_ = new ::std::string;
  }
  col_name_right_->assign(value);
  // @@protoc_insertion_point(field_set_char:DataMem.MemOperate.DbOperate.Condition.col_name_right)
}
inline void MemOperate_DbOperate_Condition::set_col_name_right(const char* value, size_t size) {
  set_has_col_name_right();
  if (col_name_right_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_name_right_ = new ::std::string;
  }
  col_name_right_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DataMem.MemOperate.DbOperate.Condition.col_name_right)
}
inline ::std::string* MemOperate_DbOperate_Condition::mutable_col_name_right() {
  set_has_col_name_right();
  if (col_name_right_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_name_right_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.DbOperate.Condition.col_name_right)
  return col_name_right_;
}
inline ::std::string* MemOperate_DbOperate_Condition::release_col_name_right() {
  clear_has_col_name_right();
  if (col_name_right_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = col_name_right_;
    col_name_right_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MemOperate_DbOperate_Condition::set_allocated_col_name_right(::std::string* col_name_right) {
  if (col_name_right_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete col_name_right_;
  }
  if (col_name_right) {
    set_has_col_name_right();
    col_name_right_ = col_name_right;
  } else {
    clear_has_col_name_right();
    col_name_right_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DataMem.MemOperate.DbOperate.Condition.col_name_right)
}

// -------------------------------------------------------------------

// MemOperate_DbOperate_ConditionGroup

// required .DataMem.MemOperate.DbOperate.ConditionGroup.E_RELATION relation = 1;
inline bool MemOperate_DbOperate_ConditionGroup::has_relation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemOperate_DbOperate_ConditionGroup::set_has_relation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemOperate_DbOperate_ConditionGroup::clear_has_relation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemOperate_DbOperate_ConditionGroup::clear_relation() {
  relation_ = 0;
  clear_has_relation();
}
inline ::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION MemOperate_DbOperate_ConditionGroup::relation() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.ConditionGroup.relation)
  return static_cast< ::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION >(relation_);
}
inline void MemOperate_DbOperate_ConditionGroup::set_relation(::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION value) {
  assert(::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION_IsValid(value));
  set_has_relation();
  relation_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.ConditionGroup.relation)
}

// repeated .DataMem.MemOperate.DbOperate.Condition condition = 2;
inline int MemOperate_DbOperate_ConditionGroup::condition_size() const {
  return condition_.size();
}
inline void MemOperate_DbOperate_ConditionGroup::clear_condition() {
  condition_.Clear();
}
inline const ::DataMem::MemOperate_DbOperate_Condition& MemOperate_DbOperate_ConditionGroup::condition(int index) const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.ConditionGroup.condition)
  return condition_.Get(index);
}
inline ::DataMem::MemOperate_DbOperate_Condition* MemOperate_DbOperate_ConditionGroup::mutable_condition(int index) {
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.DbOperate.ConditionGroup.condition)
  return condition_.Mutable(index);
}
inline ::DataMem::MemOperate_DbOperate_Condition* MemOperate_DbOperate_ConditionGroup::add_condition() {
  // @@protoc_insertion_point(field_add:DataMem.MemOperate.DbOperate.ConditionGroup.condition)
  return condition_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_Condition >&
MemOperate_DbOperate_ConditionGroup::condition() const {
  // @@protoc_insertion_point(field_list:DataMem.MemOperate.DbOperate.ConditionGroup.condition)
  return condition_;
}
inline ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_Condition >*
MemOperate_DbOperate_ConditionGroup::mutable_condition() {
  // @@protoc_insertion_point(field_mutable_list:DataMem.MemOperate.DbOperate.ConditionGroup.condition)
  return &condition_;
}

// -------------------------------------------------------------------

// MemOperate_DbOperate_OrderBy

// required .DataMem.MemOperate.DbOperate.OrderBy.E_RELATION relation = 1;
inline bool MemOperate_DbOperate_OrderBy::has_relation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemOperate_DbOperate_OrderBy::set_has_relation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemOperate_DbOperate_OrderBy::clear_has_relation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemOperate_DbOperate_OrderBy::clear_relation() {
  relation_ = 0;
  clear_has_relation();
}
inline ::DataMem::MemOperate_DbOperate_OrderBy_E_RELATION MemOperate_DbOperate_OrderBy::relation() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.OrderBy.relation)
  return static_cast< ::DataMem::MemOperate_DbOperate_OrderBy_E_RELATION >(relation_);
}
inline void MemOperate_DbOperate_OrderBy::set_relation(::DataMem::MemOperate_DbOperate_OrderBy_E_RELATION value) {
  assert(::DataMem::MemOperate_DbOperate_OrderBy_E_RELATION_IsValid(value));
  set_has_relation();
  relation_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.OrderBy.relation)
}

// required string col_name = 2;
inline bool MemOperate_DbOperate_OrderBy::has_col_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemOperate_DbOperate_OrderBy::set_has_col_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemOperate_DbOperate_OrderBy::clear_has_col_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemOperate_DbOperate_OrderBy::clear_col_name() {
  if (col_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_name_->clear();
  }
  clear_has_col_name();
}
inline const ::std::string& MemOperate_DbOperate_OrderBy::col_name() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.OrderBy.col_name)
  return *col_name_;
}
inline void MemOperate_DbOperate_OrderBy::set_col_name(const ::std::string& value) {
  set_has_col_name();
  if (col_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_name_ = new ::std::string;
  }
  col_name_->assign(value);
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.OrderBy.col_name)
}
inline void MemOperate_DbOperate_OrderBy::set_col_name(const char* value) {
  set_has_col_name();
  if (col_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_name_ = new ::std::string;
  }
  col_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:DataMem.MemOperate.DbOperate.OrderBy.col_name)
}
inline void MemOperate_DbOperate_OrderBy::set_col_name(const char* value, size_t size) {
  set_has_col_name();
  if (col_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_name_ = new ::std::string;
  }
  col_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DataMem.MemOperate.DbOperate.OrderBy.col_name)
}
inline ::std::string* MemOperate_DbOperate_OrderBy::mutable_col_name() {
  set_has_col_name();
  if (col_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.DbOperate.OrderBy.col_name)
  return col_name_;
}
inline ::std::string* MemOperate_DbOperate_OrderBy::release_col_name() {
  clear_has_col_name();
  if (col_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = col_name_;
    col_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MemOperate_DbOperate_OrderBy::set_allocated_col_name(::std::string* col_name) {
  if (col_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete col_name_;
  }
  if (col_name) {
    set_has_col_name();
    col_name_ = col_name;
  } else {
    clear_has_col_name();
    col_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DataMem.MemOperate.DbOperate.OrderBy.col_name)
}

// -------------------------------------------------------------------

// MemOperate_DbOperate

// required .DataMem.MemOperate.DbOperate.E_QUERY_TYPE query_type = 1;
inline bool MemOperate_DbOperate::has_query_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemOperate_DbOperate::set_has_query_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemOperate_DbOperate::clear_has_query_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemOperate_DbOperate::clear_query_type() {
  query_type_ = 0;
  clear_has_query_type();
}
inline ::DataMem::MemOperate_DbOperate_E_QUERY_TYPE MemOperate_DbOperate::query_type() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.query_type)
  return static_cast< ::DataMem::MemOperate_DbOperate_E_QUERY_TYPE >(query_type_);
}
inline void MemOperate_DbOperate::set_query_type(::DataMem::MemOperate_DbOperate_E_QUERY_TYPE value) {
  assert(::DataMem::MemOperate_DbOperate_E_QUERY_TYPE_IsValid(value));
  set_has_query_type();
  query_type_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.query_type)
}

// required string table_name = 2;
inline bool MemOperate_DbOperate::has_table_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemOperate_DbOperate::set_has_table_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemOperate_DbOperate::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemOperate_DbOperate::clear_table_name() {
  if (table_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_name_->clear();
  }
  clear_has_table_name();
}
inline const ::std::string& MemOperate_DbOperate::table_name() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.table_name)
  return *table_name_;
}
inline void MemOperate_DbOperate::set_table_name(const ::std::string& value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.table_name)
}
inline void MemOperate_DbOperate::set_table_name(const char* value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:DataMem.MemOperate.DbOperate.table_name)
}
inline void MemOperate_DbOperate::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DataMem.MemOperate.DbOperate.table_name)
}
inline ::std::string* MemOperate_DbOperate::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.DbOperate.table_name)
  return table_name_;
}
inline ::std::string* MemOperate_DbOperate::release_table_name() {
  clear_has_table_name();
  if (table_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = table_name_;
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MemOperate_DbOperate::set_allocated_table_name(::std::string* table_name) {
  if (table_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete table_name_;
  }
  if (table_name) {
    set_has_table_name();
    table_name_ = table_name;
  } else {
    clear_has_table_name();
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DataMem.MemOperate.DbOperate.table_name)
}

// repeated .DataMem.Field fields = 3;
inline int MemOperate_DbOperate::fields_size() const {
  return fields_.size();
}
inline void MemOperate_DbOperate::clear_fields() {
  fields_.Clear();
}
inline const ::DataMem::Field& MemOperate_DbOperate::fields(int index) const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.fields)
  return fields_.Get(index);
}
inline ::DataMem::Field* MemOperate_DbOperate::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.DbOperate.fields)
  return fields_.Mutable(index);
}
inline ::DataMem::Field* MemOperate_DbOperate::add_fields() {
  // @@protoc_insertion_point(field_add:DataMem.MemOperate.DbOperate.fields)
  return fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DataMem::Field >&
MemOperate_DbOperate::fields() const {
  // @@protoc_insertion_point(field_list:DataMem.MemOperate.DbOperate.fields)
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::DataMem::Field >*
MemOperate_DbOperate::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:DataMem.MemOperate.DbOperate.fields)
  return &fields_;
}

// repeated .DataMem.MemOperate.DbOperate.ConditionGroup conditions = 4;
inline int MemOperate_DbOperate::conditions_size() const {
  return conditions_.size();
}
inline void MemOperate_DbOperate::clear_conditions() {
  conditions_.Clear();
}
inline const ::DataMem::MemOperate_DbOperate_ConditionGroup& MemOperate_DbOperate::conditions(int index) const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.conditions)
  return conditions_.Get(index);
}
inline ::DataMem::MemOperate_DbOperate_ConditionGroup* MemOperate_DbOperate::mutable_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.DbOperate.conditions)
  return conditions_.Mutable(index);
}
inline ::DataMem::MemOperate_DbOperate_ConditionGroup* MemOperate_DbOperate::add_conditions() {
  // @@protoc_insertion_point(field_add:DataMem.MemOperate.DbOperate.conditions)
  return conditions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_ConditionGroup >&
MemOperate_DbOperate::conditions() const {
  // @@protoc_insertion_point(field_list:DataMem.MemOperate.DbOperate.conditions)
  return conditions_;
}
inline ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_ConditionGroup >*
MemOperate_DbOperate::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_list:DataMem.MemOperate.DbOperate.conditions)
  return &conditions_;
}

// repeated string groupby_col = 5;
inline int MemOperate_DbOperate::groupby_col_size() const {
  return groupby_col_.size();
}
inline void MemOperate_DbOperate::clear_groupby_col() {
  groupby_col_.Clear();
}
inline const ::std::string& MemOperate_DbOperate::groupby_col(int index) const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.groupby_col)
  return groupby_col_.Get(index);
}
inline ::std::string* MemOperate_DbOperate::mutable_groupby_col(int index) {
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.DbOperate.groupby_col)
  return groupby_col_.Mutable(index);
}
inline void MemOperate_DbOperate::set_groupby_col(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.groupby_col)
  groupby_col_.Mutable(index)->assign(value);
}
inline void MemOperate_DbOperate::set_groupby_col(int index, const char* value) {
  groupby_col_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DataMem.MemOperate.DbOperate.groupby_col)
}
inline void MemOperate_DbOperate::set_groupby_col(int index, const char* value, size_t size) {
  groupby_col_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DataMem.MemOperate.DbOperate.groupby_col)
}
inline ::std::string* MemOperate_DbOperate::add_groupby_col() {
  return groupby_col_.Add();
}
inline void MemOperate_DbOperate::add_groupby_col(const ::std::string& value) {
  groupby_col_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DataMem.MemOperate.DbOperate.groupby_col)
}
inline void MemOperate_DbOperate::add_groupby_col(const char* value) {
  groupby_col_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DataMem.MemOperate.DbOperate.groupby_col)
}
inline void MemOperate_DbOperate::add_groupby_col(const char* value, size_t size) {
  groupby_col_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DataMem.MemOperate.DbOperate.groupby_col)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MemOperate_DbOperate::groupby_col() const {
  // @@protoc_insertion_point(field_list:DataMem.MemOperate.DbOperate.groupby_col)
  return groupby_col_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MemOperate_DbOperate::mutable_groupby_col() {
  // @@protoc_insertion_point(field_mutable_list:DataMem.MemOperate.DbOperate.groupby_col)
  return &groupby_col_;
}

// repeated .DataMem.MemOperate.DbOperate.OrderBy orderby_col = 6;
inline int MemOperate_DbOperate::orderby_col_size() const {
  return orderby_col_.size();
}
inline void MemOperate_DbOperate::clear_orderby_col() {
  orderby_col_.Clear();
}
inline const ::DataMem::MemOperate_DbOperate_OrderBy& MemOperate_DbOperate::orderby_col(int index) const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.orderby_col)
  return orderby_col_.Get(index);
}
inline ::DataMem::MemOperate_DbOperate_OrderBy* MemOperate_DbOperate::mutable_orderby_col(int index) {
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.DbOperate.orderby_col)
  return orderby_col_.Mutable(index);
}
inline ::DataMem::MemOperate_DbOperate_OrderBy* MemOperate_DbOperate::add_orderby_col() {
  // @@protoc_insertion_point(field_add:DataMem.MemOperate.DbOperate.orderby_col)
  return orderby_col_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_OrderBy >&
MemOperate_DbOperate::orderby_col() const {
  // @@protoc_insertion_point(field_list:DataMem.MemOperate.DbOperate.orderby_col)
  return orderby_col_;
}
inline ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_OrderBy >*
MemOperate_DbOperate::mutable_orderby_col() {
  // @@protoc_insertion_point(field_mutable_list:DataMem.MemOperate.DbOperate.orderby_col)
  return &orderby_col_;
}

// optional .DataMem.MemOperate.DbOperate.ConditionGroup.E_RELATION group_relation = 7;
inline bool MemOperate_DbOperate::has_group_relation() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MemOperate_DbOperate::set_has_group_relation() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MemOperate_DbOperate::clear_has_group_relation() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MemOperate_DbOperate::clear_group_relation() {
  group_relation_ = 0;
  clear_has_group_relation();
}
inline ::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION MemOperate_DbOperate::group_relation() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.group_relation)
  return static_cast< ::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION >(group_relation_);
}
inline void MemOperate_DbOperate::set_group_relation(::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION value) {
  assert(::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION_IsValid(value));
  set_has_group_relation();
  group_relation_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.group_relation)
}

// optional uint32 limit = 8;
inline bool MemOperate_DbOperate::has_limit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MemOperate_DbOperate::set_has_limit() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MemOperate_DbOperate::clear_has_limit() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MemOperate_DbOperate::clear_limit() {
  limit_ = 0u;
  clear_has_limit();
}
inline ::google::protobuf::uint32 MemOperate_DbOperate::limit() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.limit)
  return limit_;
}
inline void MemOperate_DbOperate::set_limit(::google::protobuf::uint32 value) {
  set_has_limit();
  limit_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.limit)
}

// optional uint32 limit_from = 9;
inline bool MemOperate_DbOperate::has_limit_from() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MemOperate_DbOperate::set_has_limit_from() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MemOperate_DbOperate::clear_has_limit_from() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MemOperate_DbOperate::clear_limit_from() {
  limit_from_ = 0u;
  clear_has_limit_from();
}
inline ::google::protobuf::uint32 MemOperate_DbOperate::limit_from() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.limit_from)
  return limit_from_;
}
inline void MemOperate_DbOperate::set_limit_from(::google::protobuf::uint32 value) {
  set_has_limit_from();
  limit_from_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.limit_from)
}

// optional uint32 mod_factor = 10;
inline bool MemOperate_DbOperate::has_mod_factor() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MemOperate_DbOperate::set_has_mod_factor() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MemOperate_DbOperate::clear_has_mod_factor() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MemOperate_DbOperate::clear_mod_factor() {
  mod_factor_ = 0u;
  clear_has_mod_factor();
}
inline ::google::protobuf::uint32 MemOperate_DbOperate::mod_factor() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.mod_factor)
  return mod_factor_;
}
inline void MemOperate_DbOperate::set_mod_factor(::google::protobuf::uint32 value) {
  set_has_mod_factor();
  mod_factor_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.mod_factor)
}

// -------------------------------------------------------------------

// MemOperate

// required uint32 section_factor = 1;
inline bool MemOperate::has_section_factor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemOperate::set_has_section_factor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemOperate::clear_has_section_factor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemOperate::clear_section_factor() {
  section_factor_ = 0u;
  clear_has_section_factor();
}
inline ::google::protobuf::uint32 MemOperate::section_factor() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.section_factor)
  return section_factor_;
}
inline void MemOperate::set_section_factor(::google::protobuf::uint32 value) {
  set_has_section_factor();
  section_factor_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.section_factor)
}

// optional .DataMem.MemOperate.RedisOperate redis_operate = 2;
inline bool MemOperate::has_redis_operate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemOperate::set_has_redis_operate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemOperate::clear_has_redis_operate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemOperate::clear_redis_operate() {
  if (redis_operate_ != NULL) redis_operate_->::DataMem::MemOperate_RedisOperate::Clear();
  clear_has_redis_operate();
}
inline const ::DataMem::MemOperate_RedisOperate& MemOperate::redis_operate() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.redis_operate)
  return redis_operate_ != NULL ? *redis_operate_ : *default_instance_->redis_operate_;
}
inline ::DataMem::MemOperate_RedisOperate* MemOperate::mutable_redis_operate() {
  set_has_redis_operate();
  if (redis_operate_ == NULL) redis_operate_ = new ::DataMem::MemOperate_RedisOperate;
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.redis_operate)
  return redis_operate_;
}
inline ::DataMem::MemOperate_RedisOperate* MemOperate::release_redis_operate() {
  clear_has_redis_operate();
  ::DataMem::MemOperate_RedisOperate* temp = redis_operate_;
  redis_operate_ = NULL;
  return temp;
}
inline void MemOperate::set_allocated_redis_operate(::DataMem::MemOperate_RedisOperate* redis_operate) {
  delete redis_operate_;
  redis_operate_ = redis_operate;
  if (redis_operate) {
    set_has_redis_operate();
  } else {
    clear_has_redis_operate();
  }
  // @@protoc_insertion_point(field_set_allocated:DataMem.MemOperate.redis_operate)
}

// optional .DataMem.MemOperate.DbOperate db_operate = 3;
inline bool MemOperate::has_db_operate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemOperate::set_has_db_operate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemOperate::clear_has_db_operate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemOperate::clear_db_operate() {
  if (db_operate_ != NULL) db_operate_->::DataMem::MemOperate_DbOperate::Clear();
  clear_has_db_operate();
}
inline const ::DataMem::MemOperate_DbOperate& MemOperate::db_operate() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.db_operate)
  return db_operate_ != NULL ? *db_operate_ : *default_instance_->db_operate_;
}
inline ::DataMem::MemOperate_DbOperate* MemOperate::mutable_db_operate() {
  set_has_db_operate();
  if (db_operate_ == NULL) db_operate_ = new ::DataMem::MemOperate_DbOperate;
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.db_operate)
  return db_operate_;
}
inline ::DataMem::MemOperate_DbOperate* MemOperate::release_db_operate() {
  clear_has_db_operate();
  ::DataMem::MemOperate_DbOperate* temp = db_operate_;
  db_operate_ = NULL;
  return temp;
}
inline void MemOperate::set_allocated_db_operate(::DataMem::MemOperate_DbOperate* db_operate) {
  delete db_operate_;
  db_operate_ = db_operate;
  if (db_operate) {
    set_has_db_operate();
  } else {
    clear_has_db_operate();
  }
  // @@protoc_insertion_point(field_set_allocated:DataMem.MemOperate.db_operate)
}

// -------------------------------------------------------------------

// Record

// repeated .DataMem.Field field_info = 1;
inline int Record::field_info_size() const {
  return field_info_.size();
}
inline void Record::clear_field_info() {
  field_info_.Clear();
}
inline const ::DataMem::Field& Record::field_info(int index) const {
  // @@protoc_insertion_point(field_get:DataMem.Record.field_info)
  return field_info_.Get(index);
}
inline ::DataMem::Field* Record::mutable_field_info(int index) {
  // @@protoc_insertion_point(field_mutable:DataMem.Record.field_info)
  return field_info_.Mutable(index);
}
inline ::DataMem::Field* Record::add_field_info() {
  // @@protoc_insertion_point(field_add:DataMem.Record.field_info)
  return field_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DataMem::Field >&
Record::field_info() const {
  // @@protoc_insertion_point(field_list:DataMem.Record.field_info)
  return field_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::DataMem::Field >*
Record::mutable_field_info() {
  // @@protoc_insertion_point(field_mutable_list:DataMem.Record.field_info)
  return &field_info_;
}

// -------------------------------------------------------------------

// Field

// optional string col_name = 1;
inline bool Field::has_col_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Field::set_has_col_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Field::clear_has_col_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Field::clear_col_name() {
  if (col_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_name_->clear();
  }
  clear_has_col_name();
}
inline const ::std::string& Field::col_name() const {
  // @@protoc_insertion_point(field_get:DataMem.Field.col_name)
  return *col_name_;
}
inline void Field::set_col_name(const ::std::string& value) {
  set_has_col_name();
  if (col_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_name_ = new ::std::string;
  }
  col_name_->assign(value);
  // @@protoc_insertion_point(field_set:DataMem.Field.col_name)
}
inline void Field::set_col_name(const char* value) {
  set_has_col_name();
  if (col_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_name_ = new ::std::string;
  }
  col_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:DataMem.Field.col_name)
}
inline void Field::set_col_name(const char* value, size_t size) {
  set_has_col_name();
  if (col_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_name_ = new ::std::string;
  }
  col_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DataMem.Field.col_name)
}
inline ::std::string* Field::mutable_col_name() {
  set_has_col_name();
  if (col_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DataMem.Field.col_name)
  return col_name_;
}
inline ::std::string* Field::release_col_name() {
  clear_has_col_name();
  if (col_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = col_name_;
    col_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Field::set_allocated_col_name(::std::string* col_name) {
  if (col_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete col_name_;
  }
  if (col_name) {
    set_has_col_name();
    col_name_ = col_name;
  } else {
    clear_has_col_name();
    col_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DataMem.Field.col_name)
}

// optional .DataMem.E_COL_TYPE col_type = 2;
inline bool Field::has_col_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Field::set_has_col_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Field::clear_has_col_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Field::clear_col_type() {
  col_type_ = 0;
  clear_has_col_type();
}
inline ::DataMem::E_COL_TYPE Field::col_type() const {
  // @@protoc_insertion_point(field_get:DataMem.Field.col_type)
  return static_cast< ::DataMem::E_COL_TYPE >(col_type_);
}
inline void Field::set_col_type(::DataMem::E_COL_TYPE value) {
  assert(::DataMem::E_COL_TYPE_IsValid(value));
  set_has_col_type();
  col_type_ = value;
  // @@protoc_insertion_point(field_set:DataMem.Field.col_type)
}

// optional bytes col_value = 3;
inline bool Field::has_col_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Field::set_has_col_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Field::clear_has_col_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Field::clear_col_value() {
  if (col_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_value_->clear();
  }
  clear_has_col_value();
}
inline const ::std::string& Field::col_value() const {
  // @@protoc_insertion_point(field_get:DataMem.Field.col_value)
  return *col_value_;
}
inline void Field::set_col_value(const ::std::string& value) {
  set_has_col_value();
  if (col_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_value_ = new ::std::string;
  }
  col_value_->assign(value);
  // @@protoc_insertion_point(field_set:DataMem.Field.col_value)
}
inline void Field::set_col_value(const char* value) {
  set_has_col_value();
  if (col_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_value_ = new ::std::string;
  }
  col_value_->assign(value);
  // @@protoc_insertion_point(field_set_char:DataMem.Field.col_value)
}
inline void Field::set_col_value(const void* value, size_t size) {
  set_has_col_value();
  if (col_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_value_ = new ::std::string;
  }
  col_value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DataMem.Field.col_value)
}
inline ::std::string* Field::mutable_col_value() {
  set_has_col_value();
  if (col_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DataMem.Field.col_value)
  return col_value_;
}
inline ::std::string* Field::release_col_value() {
  clear_has_col_value();
  if (col_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = col_value_;
    col_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Field::set_allocated_col_value(::std::string* col_value) {
  if (col_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete col_value_;
  }
  if (col_value) {
    set_has_col_value();
    col_value_ = col_value;
  } else {
    clear_has_col_value();
    col_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DataMem.Field.col_value)
}

// optional string col_as = 4;
inline bool Field::has_col_as() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Field::set_has_col_as() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Field::clear_has_col_as() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Field::clear_col_as() {
  if (col_as_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_as_->clear();
  }
  clear_has_col_as();
}
inline const ::std::string& Field::col_as() const {
  // @@protoc_insertion_point(field_get:DataMem.Field.col_as)
  return *col_as_;
}
inline void Field::set_col_as(const ::std::string& value) {
  set_has_col_as();
  if (col_as_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_as_ = new ::std::string;
  }
  col_as_->assign(value);
  // @@protoc_insertion_point(field_set:DataMem.Field.col_as)
}
inline void Field::set_col_as(const char* value) {
  set_has_col_as();
  if (col_as_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_as_ = new ::std::string;
  }
  col_as_->assign(value);
  // @@protoc_insertion_point(field_set_char:DataMem.Field.col_as)
}
inline void Field::set_col_as(const char* value, size_t size) {
  set_has_col_as();
  if (col_as_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_as_ = new ::std::string;
  }
  col_as_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DataMem.Field.col_as)
}
inline ::std::string* Field::mutable_col_as() {
  set_has_col_as();
  if (col_as_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    col_as_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DataMem.Field.col_as)
  return col_as_;
}
inline ::std::string* Field::release_col_as() {
  clear_has_col_as();
  if (col_as_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = col_as_;
    col_as_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Field::set_allocated_col_as(::std::string* col_as) {
  if (col_as_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete col_as_;
  }
  if (col_as) {
    set_has_col_as();
    col_as_ = col_as;
  } else {
    clear_has_col_as();
    col_as_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DataMem.Field.col_as)
}

// -------------------------------------------------------------------

// MemRsp_DataLocate

// required uint32 section_from = 1;
inline bool MemRsp_DataLocate::has_section_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemRsp_DataLocate::set_has_section_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemRsp_DataLocate::clear_has_section_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemRsp_DataLocate::clear_section_from() {
  section_from_ = 0u;
  clear_has_section_from();
}
inline ::google::protobuf::uint32 MemRsp_DataLocate::section_from() const {
  // @@protoc_insertion_point(field_get:DataMem.MemRsp.DataLocate.section_from)
  return section_from_;
}
inline void MemRsp_DataLocate::set_section_from(::google::protobuf::uint32 value) {
  set_has_section_from();
  section_from_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemRsp.DataLocate.section_from)
}

// required uint32 section_to = 2;
inline bool MemRsp_DataLocate::has_section_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemRsp_DataLocate::set_has_section_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemRsp_DataLocate::clear_has_section_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemRsp_DataLocate::clear_section_to() {
  section_to_ = 0u;
  clear_has_section_to();
}
inline ::google::protobuf::uint32 MemRsp_DataLocate::section_to() const {
  // @@protoc_insertion_point(field_get:DataMem.MemRsp.DataLocate.section_to)
  return section_to_;
}
inline void MemRsp_DataLocate::set_section_to(::google::protobuf::uint32 value) {
  set_has_section_to();
  section_to_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemRsp.DataLocate.section_to)
}

// optional uint32 hash = 3;
inline bool MemRsp_DataLocate::has_hash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemRsp_DataLocate::set_has_hash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemRsp_DataLocate::clear_has_hash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemRsp_DataLocate::clear_hash() {
  hash_ = 0u;
  clear_has_hash();
}
inline ::google::protobuf::uint32 MemRsp_DataLocate::hash() const {
  // @@protoc_insertion_point(field_get:DataMem.MemRsp.DataLocate.hash)
  return hash_;
}
inline void MemRsp_DataLocate::set_hash(::google::protobuf::uint32 value) {
  set_has_hash();
  hash_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemRsp.DataLocate.hash)
}

// optional uint32 divisor = 4;
inline bool MemRsp_DataLocate::has_divisor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MemRsp_DataLocate::set_has_divisor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MemRsp_DataLocate::clear_has_divisor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MemRsp_DataLocate::clear_divisor() {
  divisor_ = 0u;
  clear_has_divisor();
}
inline ::google::protobuf::uint32 MemRsp_DataLocate::divisor() const {
  // @@protoc_insertion_point(field_get:DataMem.MemRsp.DataLocate.divisor)
  return divisor_;
}
inline void MemRsp_DataLocate::set_divisor(::google::protobuf::uint32 value) {
  set_has_divisor();
  divisor_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemRsp.DataLocate.divisor)
}

// -------------------------------------------------------------------

// MemRsp

// required int32 err_no = 1;
inline bool MemRsp::has_err_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemRsp::set_has_err_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemRsp::clear_has_err_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemRsp::clear_err_no() {
  err_no_ = 0;
  clear_has_err_no();
}
inline ::google::protobuf::int32 MemRsp::err_no() const {
  // @@protoc_insertion_point(field_get:DataMem.MemRsp.err_no)
  return err_no_;
}
inline void MemRsp::set_err_no(::google::protobuf::int32 value) {
  set_has_err_no();
  err_no_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemRsp.err_no)
}

// optional bytes err_msg = 2;
inline bool MemRsp::has_err_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemRsp::set_has_err_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemRsp::clear_has_err_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemRsp::clear_err_msg() {
  if (err_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    err_msg_->clear();
  }
  clear_has_err_msg();
}
inline const ::std::string& MemRsp::err_msg() const {
  // @@protoc_insertion_point(field_get:DataMem.MemRsp.err_msg)
  return *err_msg_;
}
inline void MemRsp::set_err_msg(const ::std::string& value) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
  // @@protoc_insertion_point(field_set:DataMem.MemRsp.err_msg)
}
inline void MemRsp::set_err_msg(const char* value) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:DataMem.MemRsp.err_msg)
}
inline void MemRsp::set_err_msg(const void* value, size_t size) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DataMem.MemRsp.err_msg)
}
inline ::std::string* MemRsp::mutable_err_msg() {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    err_msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DataMem.MemRsp.err_msg)
  return err_msg_;
}
inline ::std::string* MemRsp::release_err_msg() {
  clear_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = err_msg_;
    err_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MemRsp::set_allocated_err_msg(::std::string* err_msg) {
  if (err_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete err_msg_;
  }
  if (err_msg) {
    set_has_err_msg();
    err_msg_ = err_msg;
  } else {
    clear_has_err_msg();
    err_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DataMem.MemRsp.err_msg)
}

// optional int32 totalcount = 3;
inline bool MemRsp::has_totalcount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemRsp::set_has_totalcount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemRsp::clear_has_totalcount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemRsp::clear_totalcount() {
  totalcount_ = 0;
  clear_has_totalcount();
}
inline ::google::protobuf::int32 MemRsp::totalcount() const {
  // @@protoc_insertion_point(field_get:DataMem.MemRsp.totalcount)
  return totalcount_;
}
inline void MemRsp::set_totalcount(::google::protobuf::int32 value) {
  set_has_totalcount();
  totalcount_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemRsp.totalcount)
}

// optional int32 curcount = 4;
inline bool MemRsp::has_curcount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MemRsp::set_has_curcount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MemRsp::clear_has_curcount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MemRsp::clear_curcount() {
  curcount_ = 0;
  clear_has_curcount();
}
inline ::google::protobuf::int32 MemRsp::curcount() const {
  // @@protoc_insertion_point(field_get:DataMem.MemRsp.curcount)
  return curcount_;
}
inline void MemRsp::set_curcount(::google::protobuf::int32 value) {
  set_has_curcount();
  curcount_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemRsp.curcount)
}

// repeated .DataMem.Record record_data = 5;
inline int MemRsp::record_data_size() const {
  return record_data_.size();
}
inline void MemRsp::clear_record_data() {
  record_data_.Clear();
}
inline const ::DataMem::Record& MemRsp::record_data(int index) const {
  // @@protoc_insertion_point(field_get:DataMem.MemRsp.record_data)
  return record_data_.Get(index);
}
inline ::DataMem::Record* MemRsp::mutable_record_data(int index) {
  // @@protoc_insertion_point(field_mutable:DataMem.MemRsp.record_data)
  return record_data_.Mutable(index);
}
inline ::DataMem::Record* MemRsp::add_record_data() {
  // @@protoc_insertion_point(field_add:DataMem.MemRsp.record_data)
  return record_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DataMem::Record >&
MemRsp::record_data() const {
  // @@protoc_insertion_point(field_list:DataMem.MemRsp.record_data)
  return record_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::DataMem::Record >*
MemRsp::mutable_record_data() {
  // @@protoc_insertion_point(field_mutable_list:DataMem.MemRsp.record_data)
  return &record_data_;
}

// optional int32 from = 6;
inline bool MemRsp::has_from() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MemRsp::set_has_from() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MemRsp::clear_has_from() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MemRsp::clear_from() {
  from_ = 0;
  clear_has_from();
}
inline ::google::protobuf::int32 MemRsp::from() const {
  // @@protoc_insertion_point(field_get:DataMem.MemRsp.from)
  return from_;
}
inline void MemRsp::set_from(::google::protobuf::int32 value) {
  set_has_from();
  from_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemRsp.from)
}

// optional .DataMem.MemRsp.DataLocate locate = 7;
inline bool MemRsp::has_locate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MemRsp::set_has_locate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MemRsp::clear_has_locate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MemRsp::clear_locate() {
  if (locate_ != NULL) locate_->::DataMem::MemRsp_DataLocate::Clear();
  clear_has_locate();
}
inline const ::DataMem::MemRsp_DataLocate& MemRsp::locate() const {
  // @@protoc_insertion_point(field_get:DataMem.MemRsp.locate)
  return locate_ != NULL ? *locate_ : *default_instance_->locate_;
}
inline ::DataMem::MemRsp_DataLocate* MemRsp::mutable_locate() {
  set_has_locate();
  if (locate_ == NULL) locate_ = new ::DataMem::MemRsp_DataLocate;
  // @@protoc_insertion_point(field_mutable:DataMem.MemRsp.locate)
  return locate_;
}
inline ::DataMem::MemRsp_DataLocate* MemRsp::release_locate() {
  clear_has_locate();
  ::DataMem::MemRsp_DataLocate* temp = locate_;
  locate_ = NULL;
  return temp;
}
inline void MemRsp::set_allocated_locate(::DataMem::MemRsp_DataLocate* locate) {
  delete locate_;
  locate_ = locate;
  if (locate) {
    set_has_locate();
  } else {
    clear_has_locate();
  }
  // @@protoc_insertion_point(field_set_allocated:DataMem.MemRsp.locate)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace DataMem

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::DataMem::MemOperate_RedisOperate_OPERATE_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DataMem::MemOperate_RedisOperate_OPERATE_TYPE>() {
  return ::DataMem::MemOperate_RedisOperate_OPERATE_TYPE_descriptor();
}
template <> struct is_proto_enum< ::DataMem::MemOperate_DbOperate_Condition_E_RELATION> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DataMem::MemOperate_DbOperate_Condition_E_RELATION>() {
  return ::DataMem::MemOperate_DbOperate_Condition_E_RELATION_descriptor();
}
template <> struct is_proto_enum< ::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION>() {
  return ::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION_descriptor();
}
template <> struct is_proto_enum< ::DataMem::MemOperate_DbOperate_OrderBy_E_RELATION> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DataMem::MemOperate_DbOperate_OrderBy_E_RELATION>() {
  return ::DataMem::MemOperate_DbOperate_OrderBy_E_RELATION_descriptor();
}
template <> struct is_proto_enum< ::DataMem::MemOperate_DbOperate_E_QUERY_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DataMem::MemOperate_DbOperate_E_QUERY_TYPE>() {
  return ::DataMem::MemOperate_DbOperate_E_QUERY_TYPE_descriptor();
}
template <> struct is_proto_enum< ::DataMem::MemRsp_E_RESULT_FROM> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DataMem::MemRsp_E_RESULT_FROM>() {
  return ::DataMem::MemRsp_E_RESULT_FROM_descriptor();
}
template <> struct is_proto_enum< ::DataMem::E_COL_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DataMem::E_COL_TYPE>() {
  return ::DataMem::E_COL_TYPE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_dataproxy_2eproto__INCLUDED
